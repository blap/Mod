"""\nCompatibility layer for plugin system to handle import differences and ensure\nbackward compatibility between different plugin implementations.\n"""\n\nimport threading\nfrom typing import Any, Optional, Dict\nfrom plugin_system.plugin_base import PluginState as NewPluginState, PluginMetadata as NewPluginMetadata, PluginConfig as NewPluginConfig, IPlugin as NewIPlugin, IOptimizationPlugin as NewIOptimizationPlugin, IMemoryManagementPlugin as NewIMemoryManagementPlugin, IAttentionPlugin as NewIAttentionPlugin, ICPUPlugin as NewICPUPlugin, IPowerManagementPlugin as NewIPowerManagementPlugin, IThermalManagementPlugin as NewIThermalManagementPlugin, ICacheManagementPlugin as NewICacheManagementPlugin, IModelOptimizationPlugin as NewIModelOptimizationPlugin, BasePlugin as NewBasePlugin\n    PluginState as NewPluginState,\n    PluginMetadata as NewPluginMetadata,\n    PluginConfig as NewPluginConfig,\n    IPlugin as NewIPlugin,\n    IOptimizationPlugin as NewIOptimizationPlugin,\n    IMemoryManagementPlugin as NewIMemoryManagementPlugin,\n    IAttentionPlugin as NewIAttentionPlugin,\n    ICPUPlugin as NewICPUPlugin,\n    IPowerManagementPlugin as NewIPowerManagementPlugin,\n    IThermalManagementPlugin as NewIThermalManagementPlugin,\n    ICacheManagementPlugin as NewICacheManagementPlugin,\n    IModelOptimizationPlugin as NewIModelOptimizationPlugin,\n    BasePlugin as NewBasePlugin\n)\nfrom plugin_system.registry import PluginRegistry\nfrom plugin_system.core import PluginType\n\n\nclass LegacyPluginWrapper(NewBasePlugin):\n    """\n    Wrapper to convert legacy components into plugins.\n    """\n    def __init__(self, legacy_component: Any, plugin_type: PluginType, plugin_name: str):\n        metadata = NewPluginMetadata(\n            name=plugin_name,\n            version="1.0.0",\n            description=f"Wrapped legacy component: {type(legacy_component).__name__}",\n            author="System",\n            plugin_type=plugin_type.value if hasattr(plugin_type, 'value') else str(plugin_type),\n            dependencies=[],\n            compatibility=["1.0.0"]\n        )\n        super().__init__(metadata)\n        self._legacy_component = legacy_component\n        self._wrapped_plugin_type = plugin_type\n\n    def initialize(self, config: NewPluginConfig) -> bool:\n        """Initialize the legacy component."""\n        if hasattr(self._legacy_component, 'initialize'):\n            return self._legacy_component.initialize(config)\n        return True\n\n    def activate(self) -> bool:\n        """Activate the legacy component."""\n        if hasattr(self._legacy_component, 'activate'):\n            self._legacy_component.activate()\n            return True\n        return super().activate()\n\n    def deactivate(self) -> bool:\n        """Deactivate the legacy component."""\n        if hasattr(self._legacy_component, 'deactivate'):\n            self._legacy_component.deactivate()\n            return True\n        return super().deactivate()\n\n    def get_metadata(self):\n        """Get plugin metadata."""\n        return self._metadata\n\n    def get_config(self):\n        """Get plugin configuration."""\n        return self._config\n\n    @property\n    def state(self):\n        """Get plugin state."""\n        return self._state\n\n    @property\n    def name(self):\n        """Get plugin name."""\n        return self._metadata.name\n\n    def get_legacy_component(self) -> Any:\n        """Get the wrapped legacy component."""\n        return self._legacy_component\n\n\nclass CompatibilityLayer:\n    """\n    Compatibility layer to handle legacy components and provide backward compatibility.\n    """\n    def __init__(self, registry: PluginRegistry):\n        self._registry = registry\n        self._legacy_components: Dict[str, Any] = {}\n        self._lock = threading.RLock()\n\n    def wrap_legacy_component(self, legacy_component: Any,\n                            plugin_type: PluginType,\n                            plugin_name: Optional[str] = None) -> Optional[str]:\n        """\n        Wrap a legacy component as a plugin.\n\n        Args:\n            legacy_component: The legacy component to wrap\n            plugin_type: The type of plugin to create\n            plugin_name: Optional name for the plugin (defaults to component class name)\n\n        Returns:\n            The name of the created plugin, or None if wrapping failed\n        """\n        with self._lock:\n            if plugin_name is None:\n                plugin_name = f"wrapped_{type(legacy_component).__name__}"\n\n            # Create a wrapper plugin\n            wrapper = LegacyPluginWrapper(legacy_component, plugin_type, plugin_name)\n\n            # Register the wrapper in the plugin registry\n            if self._registry.register_plugin(wrapper):\n                # Store reference to the legacy component\n                self._legacy_components[plugin_name] = legacy_component\n                return plugin_name\n\n            return None\n\n    def get_legacy_component(self, plugin_name: str) -> Optional[Any]:\n        """\n        Get the original legacy component from a wrapped plugin.\n\n        Args:\n            plugin_name: Name of the plugin\n\n        Returns:\n            The original legacy component, or None if not found\n        """\n        with self._lock:\n            return self._legacy_components.get(plugin_name)\n\n    def unwrap_plugin(self, plugin_name: str) -> bool:\n        """\n        Remove a wrapped plugin and return the legacy component to the caller.\n\n        Args:\n            plugin_name: Name of the plugin to unwrap\n\n        Returns:\n            True if successful, False otherwise\n        """\n        with self._lock:\n            # Remove from registry\n            success = self._registry.unregister_plugin(plugin_name)\n\n            # Remove from legacy components map\n            if plugin_name in self._legacy_components:\n                del self._legacy_components[plugin_name]\n\n            return success\n\n\n# Global compatibility layer instance\n_compatibility_layer: Optional[CompatibilityLayer] = None\n_layer_lock = threading.Lock()\n\n\ndef get_compatibility_layer(registry: Optional[PluginRegistry] = None) -> CompatibilityLayer:\n    """\n    Get the global compatibility layer instance.\n\n    Args:\n        registry: Optional registry to use (will use default registry if not provided)\n\n    Returns:\n        The compatibility layer instance\n    """\n    global _compatibility_layer\n    if _compatibility_layer is None:\n        with _layer_lock:\n            if _compatibility_layer is None:\n                if registry is None:\nfrom plugin_system.registry import get_plugin_registry\n                    registry = get_plugin_registry()\n                _compatibility_layer = CompatibilityLayer(registry)\n    return _compatibility_layer\n\n\n# Re-export with old names for backward compatibility\nPluginState = NewPluginState\nPluginMetadata = NewPluginMetadata\nPluginConfig = NewPluginConfig\nIPlugin = NewIPlugin\nIOptimizationPlugin = NewIOptimizationPlugin\nIMemoryManagementPlugin = NewIMemoryManagementPlugin\nIAttentionPlugin = NewIAttentionPlugin\nICPUPlugin = NewICPUPlugin\nIPowerManagementPlugin = NewIPowerManagementPlugin\nIThermalManagementPlugin = NewIThermalManagementPlugin\nICacheManagementPlugin = NewICacheManagementPlugin\nIModelOptimizationPlugin = NewIModelOptimizationPlugin\nBasePlugin = NewBasePlugin\n\n# Additional compatibility mappings for any naming differences\nPluginStatus = PluginState  # Alternative name for state\n\n# Ensure all expected attributes are available\n__all__ = [\n    'PluginState',\n    'PluginStatus',\n    'PluginMetadata',\n    'PluginConfig',\n    'IPlugin',\n    'IOptimizationPlugin',\n    'IMemoryManagementPlugin',\n    'IAttentionPlugin',\n    'ICPUPlugin',\n    'IPowerManagementPlugin',\n    'IThermalManagementPlugin',\n    'ICacheManagementPlugin',\n    'IModelOptimizationPlugin',\n    'BasePlugin',\n    'CompatibilityLayer',\n    'LegacyPluginWrapper',\n    'get_compatibility_layer'\n]