"""\nPlugin validation and testing capabilities for the optimization framework.\n\nThis module provides functionality for validating plugin correctness,\nrunning tests on plugins, and ensuring they meet quality standards.\n"""\n\nimport os\nimport sys\nimport time\nimport subprocess\nimport tempfile\nfrom typing import Dict, List, Optional, Any, Callable, Tuple\nfrom pathlib import Path\nimport logging\nimport unittest\nfrom unittest.mock import Mock, patch\nimport inspect\nimport traceback\nfrom dataclasses import dataclass\nimport threading\n\nfrom plugin_system.core import IPlugin, PluginType, PluginState, PluginMetadata, BasePlugin, IOptimizationPlugin, IMemoryManagementPlugin, IAttentionPlugin, ICPUPlugin, IPowerManagementPlugin, IThermalManagementPlugin, ICacheManagementPlugin, IModelOptimizationPlugin\n    IPlugin, PluginType, PluginState, PluginMetadata, BasePlugin,\n    IOptimizationPlugin, IMemoryManagementPlugin, IAttentionPlugin,\n    ICPUPlugin, IPowerManagementPlugin, IThermalManagementPlugin,\n    ICacheManagementPlugin, IModelOptimizationPlugin\n)\nfrom plugin_system.registry import PluginRegistry, get_plugin_registry\nfrom plugin_system.lifecycle import PluginLifecycleManager, get_lifecycle_manager\nfrom plugin_system.discovery import PluginDiscovery\nfrom plugin_system.config import PluginConfigurationManager, get_config_manager\n\n\n@dataclass\nclass ValidationResult:\n    """Result of a plugin validation operation."""\n    is_valid: bool\n    error_messages: List[str]\n    warning_messages: List[str]\n    validation_time: float\n\n\n@dataclass\nclass TestResult:\n    """Result of a plugin test operation."""\n    plugin_name: str\n    test_name: str\n    passed: bool\n    duration: float\n    error: Optional[str] = None\n    traceback_info: Optional[str] = None\n\n\nclass PluginValidator:\n    """\n    Validates plugins for correctness, compatibility, and quality standards.\n    """\n    \n    def __init__(self, registry: Optional[PluginRegistry] = None):\n        """\n        Initialize the plugin validator.\n        \n        Args:\n            registry: Optional plugin registry to use. If None, uses global registry.\n        """\n        self._registry = registry or get_plugin_registry()\n        self._logger = logging.getLogger(f"{self.__class__.__module__}.{self.__class__.__name__}")\n        self._validator_lock = threading.Lock()\n\n    def validate_plugin_by_name(self, plugin_name: str) -> ValidationResult:\n        """\n        Validate a plugin by name.\n        \n        Args:\n            plugin_name: Name of the plugin to validate\n            \n        Returns:\n            ValidationResult containing validation status and messages\n        """\n        start_time = time.time()\n        errors = []\n        warnings = []\n        \n        try:\n            plugin = self._registry.get_plugin(plugin_name)\n            if not plugin:\n                errors.append(f"Plugin {plugin_name} not found in registry")\n                return ValidationResult(False, errors, warnings, time.time() - start_time)\n            \n            # Validate metadata\n            metadata_result = self._validate_metadata(plugin.get_metadata())\n            errors.extend(metadata_result.error_messages)\n            warnings.extend(metadata_result.warning_messages)\n            \n            # Validate plugin interface compliance\n            interface_result = self._validate_interface_compliance(plugin)\n            errors.extend(interface_result.error_messages)\n            warnings.extend(interface_result.warning_messages)\n            \n            # Validate configuration\n            config_result = self._validate_configuration(plugin)\n            errors.extend(config_result.error_messages)\n            warnings.extend(config_result.warning_messages)\n            \n            # Validate dependencies\n            deps_result = self._validate_dependencies(plugin_name)\n            errors.extend(deps_result.error_messages)\n            warnings.extend(deps_result.warning_messages)\n            \n            is_valid = len(errors) == 0\n            return ValidationResult(is_valid, errors, warnings, time.time() - start_time)\n            \n        except Exception as e:\n            errors.append(f"Unexpected error during validation: {str(e)}")\n            return ValidationResult(False, errors, warnings, time.time() - start_time)\n\n    def validate_plugin_from_file(self, file_path: str) -> ValidationResult:\n        """\n        Validate a plugin from a file without loading it into the registry.\n        \n        Args:\n            file_path: Path to the plugin file\n            \n        Returns:\n            ValidationResult containing validation status and messages\n        """\n        start_time = time.time()\n        errors = []\n        warnings = []\n        \n        try:\n            # Use discovery to analyze the plugin file\n            discovery = PluginDiscovery(self._registry)\n            discovery_result = discovery.discover_plugin_in_file(file_path)\n            \n            if not discovery_result:\n                errors.append(f"No plugin class found in {file_path}")\n                return ValidationResult(False, errors, warnings, time.time() - start_time)\n            \n            if not discovery_result.is_valid:\n                errors.append(f"Plugin in {file_path} is not valid: {discovery_result.error_message}")\n                return ValidationResult(False, errors, warnings, time.time() - start_time)\n            \n            # Validate source code\n            source_result = self._validate_source_code(file_path)\n            errors.extend(source_result.error_messages)\n            warnings.extend(source_result.warning_messages)\n            \n            # Validate metadata from discovery\n            if discovery_result.metadata:\n                metadata_result = self._validate_metadata(discovery_result.metadata)\n                errors.extend(metadata_result.error_messages)\n                warnings.extend(metadata_result.warning_messages)\n            \n            is_valid = len(errors) == 0\n            return ValidationResult(is_valid, errors, warnings, time.time() - start_time)\n            \n        except Exception as e:\n            errors.append(f"Unexpected error during file validation: {str(e)}")\n            return ValidationResult(False, errors, warnings, time.time() - start_time)\n\n    def validate_all_plugins(self) -> Dict[str, ValidationResult]:\n        """\n        Validate all plugins in the registry.\n        \n        Returns:\n            Dictionary mapping plugin names to their validation results\n        """\n        results = {}\n        for plugin in self._registry.get_all_plugins():\n            plugin_name = plugin.get_metadata().name\n            results[plugin_name] = self.validate_plugin_by_name(plugin_name)\n        return results\n\n    def _validate_metadata(self, metadata: PluginMetadata) -> ValidationResult:\n        """Validate plugin metadata."""\n        errors = []\n        warnings = []\n        \n        # Validate required fields\n        if not metadata.name or not metadata.name.strip():\n            errors.append("Plugin name is required")\n        \n        if not metadata.version or not metadata.version.strip():\n            errors.append("Plugin version is required")\n        \n        if not metadata.description or not metadata.description.strip():\n            warnings.append("Plugin description is recommended")\n        \n        if not metadata.author or not metadata.author.strip():\n            warnings.append("Plugin author is recommended")\n        \n        # Validate version format (simple check)\n        version_parts = metadata.version.split('.')\n        if len(version_parts) < 2:\n            warnings.append("Version should follow semantic versioning (e.g., 1.0.0)")\n        \n        # Validate plugin type\n        if not isinstance(metadata.plugin_type, PluginType):\n            errors.append("Invalid plugin type")\n        \n        # Validate dependencies\n        if not isinstance(metadata.dependencies, list):\n            errors.append("Dependencies must be a list")\n        else:\n            for dep in metadata.dependencies:\n                if not isinstance(dep, str) or not dep.strip():\n                    errors.append(f"Invalid dependency name: {dep}")\n        \n        # Validate compatibility\n        if not isinstance(metadata.compatibility, list):\n            errors.append("Compatibility must be a list")\n        \n        return ValidationResult(len(errors) == 0, errors, warnings, 0.0)\n\n    def _validate_interface_compliance(self, plugin: IPlugin) -> ValidationResult:\n        """Validate that the plugin properly implements its interface."""\n        errors = []\n        warnings = []\n        \n        # Check that required methods are implemented\n        required_methods = ['initialize', 'activate', 'deactivate', 'get_metadata', 'get_config']\n        \n        for method_name in required_methods:\n            if not hasattr(plugin, method_name):\n                errors.append(f"Plugin missing required method: {method_name}")\n            elif not callable(getattr(plugin, method_name)):\n                errors.append(f"Plugin method {method_name} is not callable")\n        \n        # Check method signatures\n        try:\n            # Check if required methods exist before checking signatures\n            if hasattr(plugin, 'initialize'):\n                init_sig = inspect.signature(plugin.initialize)\n                if len(init_sig.parameters) != 1:  # self is not counted\n                    warnings.append("initialize method should take exactly one parameter (config)")\n\n            if hasattr(plugin, 'activate'):\n                # Check activate method signature\n                activate_sig = inspect.signature(plugin.activate)\n                if len(activate_sig.parameters) != 0:\n                    warnings.append("activate method should take no parameters (except self)")\n\n            if hasattr(plugin, 'deactivate'):\n                # Check deactivate method signature\n                deactivate_sig = inspect.signature(plugin.deactivate)\n                if len(deactivate_sig.parameters) != 0:\n                    warnings.append("deactivate method should take no parameters (except self)")\n\n            if hasattr(plugin, 'get_metadata'):\n                # Check get_metadata method signature\n                get_metadata_sig = inspect.signature(plugin.get_metadata)\n                if len(get_metadata_sig.parameters) != 0:\n                    warnings.append("get_metadata method should take no parameters (except self)")\n\n            if hasattr(plugin, 'get_config'):\n                # Check get_config method signature\n                get_config_sig = inspect.signature(plugin.get_config)\n                if len(get_config_sig.parameters) != 0:\n                    warnings.append("get_config method should take no parameters (except self)")\n\n        except Exception as e:\n            warnings.append(f"Could not validate method signatures: {e}")\n        \n        return ValidationResult(len(errors) == 0, errors, warnings, 0.0)\n\n    def _validate_configuration(self, plugin: IPlugin) -> ValidationResult:\n        """Validate plugin configuration."""\n        errors = []\n        warnings = []\n        \n        try:\n            config = plugin.get_config()\n            if config is None:\n                errors.append("Plugin returned None for configuration")\n                return ValidationResult(False, errors, warnings, 0.0)\n            \n            # Try to access config properties\n            config_dict = config.to_dict()\n            if not isinstance(config_dict, dict):\n                errors.append("Plugin configuration to_dict() should return a dictionary")\n            \n        except Exception as e:\n            errors.append(f"Error accessing plugin configuration: {e}")\n        \n        return ValidationResult(len(errors) == 0, errors, warnings, 0.0)\n\n    def _validate_dependencies(self, plugin_name: str) -> ValidationResult:\n        """Validate plugin dependencies."""\n        errors = []\n        warnings = []\n        \n        dependencies = self._registry._dependencies.get(plugin_name, [])\n        \n        for dep_name in dependencies:\n            if dep_name not in self._registry._plugins:\n                errors.append(f"Dependency {dep_name} not found in registry")\n        \n        # Check for circular dependencies\n        if self._has_circular_dependency(plugin_name):\n            errors.append(f"Plugin {plugin_name} is part of a circular dependency")\n        \n        return ValidationResult(len(errors) == 0, errors, warnings, 0.0)\n\n    def _has_circular_dependency(self, plugin_name: str, visited: Optional[set] = None, \n                                rec_stack: Optional[set] = None) -> bool:\n        """Check if a plugin is part of a circular dependency."""\n        if visited is None:\n            visited = set()\n        if rec_stack is None:\n            rec_stack = set()\n        \n        if plugin_name in rec_stack:\n            return True\n        \n        if plugin_name in visited:\n            return False\n        \n        rec_stack.add(plugin_name)\n        visited.add(plugin_name)\n        \n        dependencies = self._registry._dependencies.get(plugin_name, [])\n        for dep_name in dependencies:\n            if self._has_circular_dependency(dep_name, visited, rec_stack.copy()):\n                return True\n        \n        rec_stack.remove(plugin_name)\n        return False\n\n    def _validate_source_code(self, file_path: str) -> ValidationResult:\n        """Validate plugin source code for common issues."""\n        errors = []\n        warnings = []\n        \n        try:\n            with open(file_path, 'r', encoding='utf-8') as f:\n                source = f.read()\n            \n            # Parse the source code\n            import ast\n            tree = ast.parse(source)\n            \n            # Check for common issues\n            for node in ast.walk(tree):\n                if isinstance(node, ast.ImportFrom):\n                    # Check for relative imports that might cause issues\n                    if node.module and node.module.startswith('.'):\n                        warnings.append(f"Relative import found: {node.module}")\n                \n                elif isinstance(node, ast.Call):\n                    # Check for potentially unsafe function calls\n                    if isinstance(node.func, ast.Name):\n                        if node.func.id in ['eval', 'exec', 'compile']:\n                            warnings.append(f"Potentially unsafe function call: {node.func.id}")\n        \n        except SyntaxError as e:\n            errors.append(f"Syntax error in source code: {e}")\n        except Exception as e:\n            errors.append(f"Error validating source code: {e}")\n        \n        return ValidationResult(len(errors) == 0, errors, warnings, 0.0)\n\n\nclass PluginTester:\n    """\n    Runs tests on plugins to ensure they function correctly.\n    """\n    \n    def __init__(self, \n                 registry: Optional[PluginRegistry] = None,\n                 lifecycle_manager: Optional[PluginLifecycleManager] = None,\n                 config_manager: Optional[PluginConfigurationManager] = None):\n        """\n        Initialize the plugin tester.\n        \n        Args:\n            registry: Optional plugin registry to use. If None, uses global registry.\n            lifecycle_manager: Optional lifecycle manager to use. If None, uses global manager.\n            config_manager: Optional config manager to use. If None, uses global manager.\n        """\n        self._registry = registry or get_plugin_registry()\n        self._lifecycle_manager = lifecycle_manager or get_lifecycle_manager()\n        self._config_manager = config_manager or get_config_manager()\n        self._logger = logging.getLogger(f"{self.__class__.__module__}.{self.__class__.__name__}")\n        self._tester_lock = threading.Lock()\n\n    def run_plugin_tests(self, plugin_name: str, test_types: Optional[List[str]] = None) -> List[TestResult]:\n        """\n        Run tests on a plugin.\n        \n        Args:\n            plugin_name: Name of the plugin to test\n            test_types: List of test types to run. If None, runs all tests.\n            \n        Returns:\n            List of test results\n        """\n        results = []\n        \n        plugin = self._registry.get_plugin(plugin_name)\n        if not plugin:\n            results.append(TestResult(\n                plugin_name=plugin_name,\n                test_name="plugin_exists",\n                passed=False,\n                duration=0.0,\n                error=f"Plugin {plugin_name} not found"\n            ))\n            return results\n        \n        test_types = test_types or ["interface", "lifecycle", "functionality"]\n        \n        for test_type in test_types:\n            test_func = getattr(self, f"_test_{test_type}", None)\n            if test_func:\n                start_time = time.time()\n                try:\n                    test_passed = test_func(plugin)\n                    duration = time.time() - start_time\n                    results.append(TestResult(\n                        plugin_name=plugin_name,\n                        test_name=f"{test_type}_test",\n                        passed=test_passed,\n                        duration=duration\n                    ))\n                except Exception as e:\n                    duration = time.time() - start_time\n                    results.append(TestResult(\n                        plugin_name=plugin_name,\n                        test_name=f"{test_type}_test",\n                        passed=False,\n                        duration=duration,\n                        error=str(e),\n                        traceback_info=traceback.format_exc()\n                    ))\n            else:\n                results.append(TestResult(\n                    plugin_name=plugin_name,\n                    test_name=f"{test_type}_test",\n                    passed=False,\n                    duration=0.0,\n                    error=f"Unknown test type: {test_type}"\n                ))\n        \n        return results\n\n    def run_all_plugin_tests(self, test_types: Optional[List[str]] = None) -> Dict[str, List[TestResult]]:\n        """\n        Run tests on all plugins in the registry.\n        \n        Args:\n            test_types: List of test types to run. If None, runs all tests.\n            \n        Returns:\n            Dictionary mapping plugin names to their test results\n        """\n        results = {}\n        for plugin in self._registry.get_all_plugins():\n            plugin_name = plugin.get_metadata().name\n            results[plugin_name] = self.run_plugin_tests(plugin_name, test_types)\n        return results\n\n    def _test_interface(self, plugin: IPlugin) -> bool:\n        """Test that the plugin properly implements its interface."""\n        try:\n            # Test get_metadata\n            metadata = plugin.get_metadata()\n            assert metadata is not None, "get_metadata should not return None"\n            assert isinstance(metadata, PluginMetadata), "get_metadata should return PluginMetadata"\n            \n            # Test get_config\n            config = plugin.get_config()\n            assert config is not None, "get_config should not return None"\n            assert hasattr(config, 'to_dict'), "Config should have to_dict method"\n            \n            # Test initialize with minimal config\nfrom plugin_system.core import PluginConfig\n            plugin_config = PluginConfig(plugin.get_metadata().name)\n            init_result = plugin.initialize(plugin_config)\n            assert isinstance(init_result, bool), "initialize should return boolean"\n            \n            return True\n        except Exception as e:\n            self._logger.error(f"Interface test failed: {e}")\n            return False\n\n    def _test_lifecycle(self, plugin: IPlugin) -> bool:\n        """Test plugin lifecycle methods."""\n        try:\n            # Ensure plugin is in a known state\n            if plugin.state == PluginState.ACTIVE:\n                plugin.deactivate()\n            \n            # Test activation\n            activation_result = plugin.activate()\n            assert isinstance(activation_result, bool), "activate should return boolean"\n            \n            if activation_result:\n                assert plugin.state == PluginState.ACTIVE, "Plugin should be ACTIVE after activation"\n                \n                # Test deactivation\n                deactivation_result = plugin.deactivate()\n                assert isinstance(deactivation_result, bool), "deactivate should return boolean"\n                if deactivation_result:\n                    assert plugin.state in [PluginState.INACTIVE, PluginState.INITIALIZED], \\n                           "Plugin should be INACTIVE or INITIALIZED after deactivation"\n            \n            return True\n        except Exception as e:\n            self._logger.error(f"Lifecycle test failed: {e}")\n            return False\n\n    def _test_functionality(self, plugin: IPlugin) -> bool:\n        """Test plugin functionality based on its type."""\n        try:\n            # This is a generic test - specific functionality tests would be implemented\n            # based on the plugin type\n            metadata = plugin.get_metadata()\n            \n            # For different plugin types, we might want to test specific functionality\n            # For now, just ensure the plugin can be activated and basic operations work\n            if plugin.state != PluginState.ACTIVE:\n                if not plugin.activate():\n                    return False\n            \n            # Perform a basic operation based on plugin type\n            if isinstance(plugin, IOptimizationPlugin):\n                # Test optimize method if it exists\n                pass\n            elif isinstance(plugin, IMemoryManagementPlugin):\n                # Test memory management methods if they exist\n                pass\n            elif isinstance(plugin, IAttentionPlugin):\n                # Test attention methods if they exist\n                pass\n            elif isinstance(plugin, ICPUPlugin):\n                # Test CPU optimization methods if they exist\n                pass\n            elif isinstance(plugin, IPowerManagementPlugin):\n                # Test power management methods if they exist\n                pass\n            elif isinstance(plugin, IThermalManagementPlugin):\n                # Test thermal management methods if they exist\n                pass\n            elif isinstance(plugin, ICacheManagementPlugin):\n                # Test cache management methods if they exist\n                pass\n            elif isinstance(plugin, IModelOptimizationPlugin):\n                # Test model optimization methods if they exist\n                pass\n            \n            return True\n        except Exception as e:\n            self._logger.error(f"Functionality test failed: {e}")\n            return False\n\n    def run_custom_test(self, plugin_name: str, test_func: Callable[[IPlugin], bool]) -> TestResult:\n        """\n        Run a custom test function on a plugin.\n        \n        Args:\n            plugin_name: Name of the plugin to test\n            test_func: Test function that takes a plugin and returns True/False\n            \n        Returns:\n            Test result\n        """\n        start_time = time.time()\n        \n        try:\n            plugin = self._registry.get_plugin(plugin_name)\n            if not plugin:\n                return TestResult(\n                    plugin_name=plugin_name,\n                    test_name="custom_test",\n                    passed=False,\n                    duration=time.time() - start_time,\n                    error=f"Plugin {plugin_name} not found"\n                )\n            \n            test_result = test_func(plugin)\n            return TestResult(\n                plugin_name=plugin_name,\n                test_name="custom_test",\n                passed=test_result,\n                duration=time.time() - start_time\n            )\n        except Exception as e:\n            return TestResult(\n                plugin_name=plugin_name,\n                test_name="custom_test",\n                passed=False,\n                duration=time.time() - start_time,\n                error=str(e),\n                traceback_info=traceback.format_exc()\n            )\n\n    def run_performance_test(self, plugin_name: str, iterations: int = 100) -> Dict[str, Any]:\n        """\n        Run a performance test on a plugin.\n        \n        Args:\n            plugin_name: Name of the plugin to test\n            iterations: Number of iterations to run the test\n            \n        Returns:\n            Dictionary with performance metrics\n        """\n        plugin = self._registry.get_plugin(plugin_name)\n        if not plugin:\n            return {"error": f"Plugin {plugin_name} not found"}\n        \n        # Activate plugin for testing\n        was_active = plugin.state == PluginState.ACTIVE\n        if not was_active:\n            plugin.activate()\n        \n        try:\n            # Measure basic operation performance\n            start_time = time.time()\n            for _ in range(iterations):\n                # Perform a basic plugin operation based on its type\n                if isinstance(plugin, IOptimizationPlugin):\n                    # For optimization plugins, we might call optimize with dummy data\n                    pass\n                elif isinstance(plugin, IMemoryManagementPlugin):\n                    # For memory plugins, we might do allocation/deallocation\n                    pass\n                elif isinstance(plugin, IAttentionPlugin):\n                    # For attention plugins, we might compute attention\n                    pass\n                elif isinstance(plugin, ICPUPlugin):\n                    # For CPU plugins, we might optimize CPU usage\n                    pass\n                elif isinstance(plugin, IPowerManagementPlugin):\n                    # For power plugins, we might manage power\n                    pass\n                elif isinstance(plugin, IThermalManagementPlugin):\n                    # For thermal plugins, we might manage thermal conditions\n                    pass\n                elif isinstance(plugin, ICacheManagementPlugin):\n                    # For cache plugins, we might access cache\n                    pass\n                elif isinstance(plugin, IModelOptimizationPlugin):\n                    # For model optimization plugins, we might optimize a model\n                    pass\n                else:\n                    # For base plugins, just call a basic method\n                    plugin.get_metadata()\n            \n            total_time = time.time() - start_time\n            avg_time = total_time / iterations if iterations > 0 else 0\n            \n            return {\n                "iterations": iterations,\n                "total_time": total_time,\n                "average_time_per_operation": avg_time,\n                "operations_per_second": iterations / total_time if total_time > 0 else float('inf')\n            }\n        finally:\n            # Restore original state\n            if not was_active and plugin.state == PluginState.ACTIVE:\n                plugin.deactivate()\n\n\n# Global validator and tester instances\nvalidator = PluginValidator()\ntester = PluginTester()\n\n\ndef get_plugin_validator() -> PluginValidator:\n    """\n    Get the global plugin validator instance.\n    \n    Returns:\n        PluginValidator instance\n    """\n    return validator\n\n\ndef get_plugin_tester() -> PluginTester:\n    """\n    Get the global plugin tester instance.\n    \n    Returns:\n        PluginTester instance\n    """\n    return tester