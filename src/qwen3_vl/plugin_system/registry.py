"""\nPlugin registry system for managing plugins in the optimization framework.\n\nThis module provides a centralized registry for plugins with support for\nloading, unloading, activation, and management of plugins.\n"""\n\nimport os\nimport sys\nimport importlib\nimport importlib.util\nfrom typing import Dict, List, Optional, Type, Any, Callable\nfrom pathlib import Path\nimport threading\nimport logging\nfrom collections import defaultdict\n\nfrom plugin_system.core import IPlugin, PluginType, PluginState, PluginMetadata, BasePlugin, IOptimizationPlugin, IMemoryManagementPlugin, IAttentionPlugin, ICPUPlugin, IPowerManagementPlugin, IThermalManagementPlugin, ICacheManagementPlugin, IModelOptimizationPlugin\n    IPlugin, PluginType, PluginState, PluginMetadata, BasePlugin,\n    IOptimizationPlugin, IMemoryManagementPlugin, IAttentionPlugin,\n    ICPUPlugin, IPowerManagementPlugin, IThermalManagementPlugin,\n    ICacheManagementPlugin, IModelOptimizationPlugin\n)\n\n\nclass PluginRegistry:\n    """\n    Centralized registry for managing plugins.\n    \n    This class provides functionality for registering, discovering, loading,\n    and managing plugins in the system.\n    """\n    \n    _instance = None\n    _lock = threading.RLock()\n    \n    def __new__(cls):\n        """Ensure singleton pattern."""\n        if cls._instance is None:\n            with cls._lock:\n                if cls._instance is None:\n                    cls._instance = super().__new__(cls)\n        return cls._instance\n    \n    def __init__(self):\n        """Initialize the plugin registry."""\n        # Only initialize once\n        if hasattr(self, '_initialized'):\n            return\n            \n        self._plugins: Dict[str, IPlugin] = {}\n        self._plugin_types: Dict[PluginType, List[str]] = defaultdict(list)\n        self._dependencies: Dict[str, List[str]] = defaultdict(list)  # plugin_name -> [dependencies]\n        self._dependents: Dict[str, List[str]] = defaultdict(list)    # plugin_name -> [dependents]\n        self._logger = logging.getLogger(f"{self.__class__.__module__}.{self.__class__.__name__}")\n        self._registry_lock = threading.RLock()\n        self._initialized = True\n\n    def register_plugin(self, plugin: IPlugin) -> bool:\n        """\n        Register a plugin instance in the registry.\n        \n        Args:\n            plugin: Plugin instance to register\n            \n        Returns:\n            True if registration was successful, False otherwise\n        """\n        with self._registry_lock:\n            try:\n                metadata = plugin.get_metadata()\n                plugin_name = metadata.name\n                \n                if plugin_name in self._plugins:\n                    self._logger.warning(f"Plugin {plugin_name} already registered, replacing")\n                \n                # Register the plugin\n                self._plugins[plugin_name] = plugin\n                \n                # Register by type\n                self._plugin_types[metadata.plugin_type].append(plugin_name)\n                \n                # Register dependencies\n                self._dependencies[plugin_name] = metadata.dependencies\n                for dep_name in metadata.dependencies:\n                    self._dependents[dep_name].append(plugin_name)\n                \n                self._logger.info(f"Plugin {plugin_name} registered successfully")\n                return True\n            except Exception as e:\n                self._logger.error(f"Error registering plugin: {e}")\n                return False\n\n    def unregister_plugin(self, plugin_name: str) -> bool:\n        """\n        Unregister a plugin from the registry.\n        \n        Args:\n            plugin_name: Name of the plugin to unregister\n            \n        Returns:\n            True if unregistration was successful, False otherwise\n        """\n        with self._registry_lock:\n            if plugin_name not in self._plugins:\n                self._logger.warning(f"Plugin {plugin_name} not found in registry")\n                return False\n            \n            try:\n                # Check if any other plugins depend on this one\n                dependents = self._dependents.get(plugin_name, [])\n                if dependents:\n                    self._logger.error(f"Cannot unregister {plugin_name}, following plugins depend on it: {dependents}")\n                    return False\n                \n                # Remove the plugin\n                plugin = self._plugins[plugin_name]\n                metadata = plugin.get_metadata()\n                \n                # Remove from type index\n                if plugin_name in self._plugin_types[metadata.plugin_type]:\n                    self._plugin_types[metadata.plugin_type].remove(plugin_name)\n                \n                # Remove dependencies\n                for dep_name in self._dependencies[plugin_name]:\n                    if plugin_name in self._dependents[dep_name]:\n                        self._dependents[dep_name].remove(plugin_name)\n                \n                # Remove from main registry\n                del self._plugins[plugin_name]\n                del self._dependencies[plugin_name]\n                \n                self._logger.info(f"Plugin {plugin_name} unregistered successfully")\n                return True\n            except Exception as e:\n                self._logger.error(f"Error unregistering plugin {plugin_name}: {e}")\n                return False\n\n    def get_plugin(self, plugin_name: str) -> Optional[IPlugin]:\n        """\n        Get a plugin instance by name.\n        \n        Args:\n            plugin_name: Name of the plugin to retrieve\n            \n        Returns:\n            Plugin instance if found, None otherwise\n        """\n        with self._registry_lock:\n            return self._plugins.get(plugin_name)\n\n    def get_plugins_by_type(self, plugin_type: PluginType) -> List[IPlugin]:\n        """\n        Get all plugins of a specific type.\n        \n        Args:\n            plugin_type: Type of plugins to retrieve\n            \n        Returns:\n            List of plugins of the specified type\n        """\n        with self._registry_lock:\n            plugin_names = self._plugin_types.get(plugin_type, [])\n            return [self._plugins[name] for name in plugin_names if name in self._plugins]\n\n    def get_all_plugins(self) -> List[IPlugin]:\n        """\n        Get all registered plugins.\n        \n        Returns:\n            List of all registered plugins\n        """\n        with self._registry_lock:\n            return list(self._plugins.values())\n\n    def get_plugin_state(self, plugin_name: str) -> Optional[PluginState]:\n        """\n        Get the state of a plugin.\n        \n        Args:\n            plugin_name: Name of the plugin\n            \n        Returns:\n            PluginState if plugin exists, None otherwise\n        """\n        with self._registry_lock:\n            plugin = self._plugins.get(plugin_name)\n            if plugin:\nfrom plugin_system.core import BasePlugin\n                if isinstance(plugin, BasePlugin):\n                    return plugin.state\n            return None\n\n    def get_plugin_metadata(self, plugin_name: str) -> Optional[PluginMetadata]:\n        """\n        Get metadata for a plugin.\n        \n        Args:\n            plugin_name: Name of the plugin\n            \n        Returns:\n            PluginMetadata if plugin exists, None otherwise\n        """\n        with self._registry_lock:\n            plugin = self._plugins.get(plugin_name)\n            if plugin:\n                return plugin.get_metadata()\n            return None\n\n    def activate_plugin(self, plugin_name: str) -> bool:\n        """\n        Activate a plugin by name.\n        \n        Args:\n            plugin_name: Name of the plugin to activate\n            \n        Returns:\n            True if activation was successful, False otherwise\n        """\n        with self._registry_lock:\n            plugin = self._plugins.get(plugin_name)\n            if not plugin:\n                self._logger.error(f"Plugin {plugin_name} not found")\n                return False\n            \n            # Check dependencies\n            for dep_name in self._dependencies.get(plugin_name, []):\n                dep_plugin = self._plugins.get(dep_name)\n                if not dep_plugin or dep_plugin.state != PluginState.ACTIVE:\n                    self._logger.error(f"Plugin {plugin_name} has unmet dependency: {dep_name}")\n                    return False\n            \n            return plugin.activate()\n\n    def deactivate_plugin(self, plugin_name: str) -> bool:\n        """\n        Deactivate a plugin by name.\n        \n        Args:\n            plugin_name: Name of the plugin to deactivate\n            \n        Returns:\n            True if deactivation was successful, False otherwise\n        """\n        with self._registry_lock:\n            plugin = self._plugins.get(plugin_name)\n            if not plugin:\n                self._logger.error(f"Plugin {plugin_name} not found")\n                return False\n            \n            # Check if other plugins depend on this one\n            dependents = self._dependents.get(plugin_name, [])\n            for dep_name in dependents:\n                dep_plugin = self._plugins.get(dep_name)\n                if dep_plugin and dep_plugin.state == PluginState.ACTIVE:\n                    self._logger.error(f"Cannot deactivate {plugin_name}, plugin {dep_name} depends on it")\n                    return False\n            \n            return plugin.deactivate()\n\n    def load_plugin_from_file(self, file_path: str, config_data: Optional[Dict[str, Any]] = None) -> Optional[IPlugin]:\n        """\n        Load a plugin from a Python file.\n        \n        Args:\n            file_path: Path to the plugin file\n            config_data: Optional configuration data for the plugin\n            \n        Returns:\n            Loaded plugin instance if successful, None otherwise\n        """\n        try:\n            # Import the module\n            spec = importlib.util.spec_from_file_location("plugin_module", file_path)\n            if spec is None or spec.loader is None:\n                self._logger.error(f"Could not load spec from {file_path}")\n                return None\n            \n            module = importlib.util.module_from_spec(spec)\n            spec.loader.exec_module(module)\n            \n            # Look for a class that implements IPlugin\n            plugin_class = None\n            for attr_name in dir(module):\n                attr = getattr(module, attr_name)\n                if (isinstance(attr, type) and \n                    attr != BasePlugin and \n                    issubclass(attr, BasePlugin)):\n                    plugin_class = attr\n                    break\n            \n            if plugin_class is None:\n                self._logger.error(f"No plugin class found in {file_path}")\n                return None\n            \n            # Create an instance of the plugin\n            plugin_instance = plugin_class()\n            \n            # Initialize the plugin\n            config = plugin_instance.get_metadata().config_schema or {}\n            if config_data:\n                config.update(config_data)\n            \nfrom plugin_system.core import PluginConfig\n            plugin_config = PluginConfig(\n                plugin_instance.get_metadata().name,\n                config\n            )\n            \n            if plugin_instance.initialize(plugin_config):\n                self.register_plugin(plugin_instance)\n                return plugin_instance\n            else:\n                self._logger.error(f"Failed to initialize plugin from {file_path}")\n                return None\n                \n        except Exception as e:\n            self._logger.error(f"Error loading plugin from {file_path}: {e}")\n            return None\n\n    def load_plugins_from_directory(self, directory_path: str, recursive: bool = True) -> List[str]:\n        """\n        Load all plugins from a directory.\n        \n        Args:\n            directory_path: Path to the directory containing plugin files\n            recursive: Whether to search subdirectories\n            \n        Returns:\n            List of successfully loaded plugin names\n        """\n        loaded_plugins = []\n        \n        path = Path(directory_path)\n        if not path.exists() or not path.is_dir():\n            self._logger.error(f"Directory {directory_path} does not exist or is not a directory")\n            return loaded_plugins\n        \n        # Find all Python files in the directory\n        pattern = "**/*.py" if recursive else "*.py"\n        py_files = path.glob(pattern)\n        \n        for py_file in py_files:\n            if py_file.name.startswith('__'):\n                continue  # Skip __init__.py and similar files\n            \n            plugin = self.load_plugin_from_file(str(py_file))\n            if plugin:\n                loaded_plugins.append(plugin.get_metadata().name)\n        \n        return loaded_plugins\n\n    def get_dependency_graph(self) -> Dict[str, List[str]]:\n        """\n        Get the dependency graph of plugins.\n        \n        Returns:\n            Dictionary mapping plugin names to their dependencies\n        """\n        with self._registry_lock:\n            return {name: deps[:] for name, deps in self._dependencies.items()}\n\n    def get_dependents_graph(self) -> Dict[str, List[str]]:\n        """\n        Get the dependents graph of plugins.\n        \n        Returns:\n            Dictionary mapping plugin names to plugins that depend on them\n        """\n        with self._registry_lock:\n            return {name: deps[:] for name, deps in self._dependents.items()}\n\n    def validate_dependencies(self) -> List[str]:\n        """\n        Validate that all plugin dependencies are satisfied.\n        \n        Returns:\n            List of plugins with unmet dependencies\n        """\n        with self._registry_lock:\n            unmet_deps = []\n            \n            for plugin_name, deps in self._dependencies.items():\n                for dep_name in deps:\n                    if dep_name not in self._plugins:\n                        unmet_deps.append(f"{plugin_name} requires {dep_name}")\n            \n            return unmet_deps\n\n    def get_active_plugins(self) -> List[IPlugin]:\n        """\n        Get all active plugins.\n        \n        Returns:\n            List of active plugins\n        """\n        with self._registry_lock:\n            active_plugins = []\n            for plugin in self._plugins.values():\n                if isinstance(plugin, BasePlugin) and plugin.state == PluginState.ACTIVE:\n                    active_plugins.append(plugin)\n            return active_plugins\n\n    def get_loaded_plugins(self) -> List[IPlugin]:\n        """\n        Get all loaded plugins (in any state except UNLOADED).\n        \n        Returns:\n            List of loaded plugins\n        """\n        with self._registry_lock:\n            loaded_plugins = []\n            for plugin in self._plugins.values():\n                if isinstance(plugin, BasePlugin) and plugin.state != PluginState.UNLOADED:\n                    loaded_plugins.append(plugin)\n            return loaded_plugins\n\n\n# Global registry instance\nplugin_registry = PluginRegistry()\n\n\ndef get_plugin_registry() -> PluginRegistry:\n    """\n    Get the global plugin registry instance.\n    \n    Returns:\n        PluginRegistry instance\n    """\n    return plugin_registry