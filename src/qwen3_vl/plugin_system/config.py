"""\nPlugin configuration management system for the optimization framework.\n\nThis module provides functionality for managing plugin configurations,\nincluding loading, saving, validating, and applying configurations.\n"""\n\nimport os\nimport json\nimport yaml\nfrom typing import Dict, List, Optional, Any, Union, Tuple\nfrom pathlib import Path\nimport logging\nfrom dataclasses import dataclass, asdict\nfrom jsonschema import validate, ValidationError\nimport hashlib\nimport threading\n\nfrom plugin_system.core import PluginConfig, PluginMetadata, PluginType\nfrom plugin_system.registry import PluginRegistry, get_plugin_registry\n\n\n@dataclass\nclass ConfigSchema:\n    """Configuration schema definition."""\n    type: str  # "object", "array", etc.\n    properties: Optional[Dict[str, Any]] = None\n    required: Optional[List[str]] = None\n    additionalProperties: bool = True\n    description: Optional[str] = None\n\n\nclass PluginConfigurationManager:\n    """\n    Manages configurations for plugins including loading, saving, validation,\n    and application of configurations.\n    """\n    \n    def __init__(self, registry: Optional[PluginRegistry] = None, config_dir: Optional[str] = None):\n        """\n        Initialize the plugin configuration manager.\n        \n        Args:\n            registry: Optional plugin registry to use. If None, uses global registry.\n            config_dir: Optional directory to store configuration files. If None, uses default.\n        """\n        self._registry = registry or get_plugin_registry()\n        self._config_dir = Path(config_dir) if config_dir else Path.cwd() / "configs"\n        self._config_dir.mkdir(exist_ok=True)\n        \n        self._logger = logging.getLogger(f"{self.__class__.__module__}.{self.__class__.__name__}")\n        self._config_lock = threading.RLock()\n        self._plugin_configs: Dict[str, PluginConfig] = {}\n        self._config_history: Dict[str, List[Dict[str, Any]]] = {}  # plugin_name -> [history]\n\n    def get_plugin_config(self, plugin_name: str) -> Optional[PluginConfig]:\n        """\n        Get the configuration for a plugin.\n        \n        Args:\n            plugin_name: Name of the plugin\n            \n        Returns:\n            PluginConfig if found, None otherwise\n        """\n        with self._config_lock:\n            # First check if we have it in our local cache\n            if plugin_name in self._plugin_configs:\n                return self._plugin_configs[plugin_name]\n            \n            # Then check the registry\n            plugin = self._registry.get_plugin(plugin_name)\n            if plugin:\n                config = plugin.get_config()\n                self._plugin_configs[plugin_name] = config\n                return config\n            \n            return None\n\n    def set_plugin_config(self, plugin_name: str, config_data: Dict[str, Any]) -> bool:\n        """\n        Set the configuration for a plugin.\n        \n        Args:\n            plugin_name: Name of the plugin\n            config_data: Configuration data to set\n            \n        Returns:\n            True if successful, False otherwise\n        """\n        with self._config_lock:\n            # Get the plugin\n            plugin = self._registry.get_plugin(plugin_name)\n            if not plugin:\n                self._logger.error(f"Plugin {plugin_name} not found in registry")\n                return False\n            \n            # Validate against schema if available\n            metadata = plugin.get_metadata()\n            if metadata.config_schema:\n                try:\n                    validate(instance=config_data, schema=metadata.config_schema)\n                except ValidationError as e:\n                    self._logger.error(f"Configuration validation failed for {plugin_name}: {e}")\n                    return False\n            \n            # Update the plugin's configuration\n            plugin_config = plugin.get_config()\n            plugin_config.update(config_data)\n            \n            # Store in local cache\n            self._plugin_configs[plugin_name] = plugin_config\n            \n            # Add to history\n            self._add_to_config_history(plugin_name, config_data)\n            \n            self._logger.info(f"Configuration set for plugin {plugin_name}")\n            return True\n\n    def update_plugin_config(self, plugin_name: str, updates: Dict[str, Any]) -> bool:\n        """\n        Update specific values in a plugin's configuration.\n        \n        Args:\n            plugin_name: Name of the plugin\n            updates: Dictionary of updates to apply\n            \n        Returns:\n            True if successful, False otherwise\n        """\n        with self._config_lock:\n            config = self.get_plugin_config(plugin_name)\n            if not config:\n                self._logger.error(f"Plugin {plugin_name} configuration not found")\n                return False\n            \n            # Get current config and apply updates\n            current_config = config.to_dict()\n            current_config.update(updates)\n            \n            # Validate against schema if available\n            plugin = self._registry.get_plugin(plugin_name)\n            if plugin and plugin.get_metadata().config_schema:\n                try:\n                    validate(instance=current_config, schema=plugin.get_metadata().config_schema)\n                except ValidationError as e:\n                    self._logger.error(f"Configuration validation failed for {plugin_name}: {e}")\n                    return False\n            \n            # Apply the updated configuration\n            config.update(current_config)\n            \n            # Add to history\n            self._add_to_config_history(plugin_name, current_config)\n            \n            self._logger.info(f"Configuration updated for plugin {plugin_name}")\n            return True\n\n    def get_config_schema(self, plugin_name: str) -> Optional[Dict[str, Any]]:\n        """\n        Get the configuration schema for a plugin.\n        \n        Args:\n            plugin_name: Name of the plugin\n            \n        Returns:\n            Configuration schema if available, None otherwise\n        """\n        with self._config_lock:\n            plugin = self._registry.get_plugin(plugin_name)\n            if plugin:\n                metadata = plugin.get_metadata()\n                return metadata.config_schema\n            return None\n\n    def validate_config(self, plugin_name: str, config_data: Dict[str, Any]) -> Tuple[bool, Optional[str]]:\n        """\n        Validate configuration data against the plugin's schema.\n        \n        Args:\n            plugin_name: Name of the plugin\n            config_data: Configuration data to validate\n            \n        Returns:\n            Tuple of (is_valid, error_message)\n        """\n        with self._config_lock:\n            schema = self.get_config_schema(plugin_name)\n            if not schema:\n                return True, None  # No schema to validate against\n            \n            try:\n                validate(instance=config_data, schema=schema)\n                return True, None\n            except ValidationError as e:\n                return False, str(e)\n\n    def save_config_to_file(self, plugin_name: str, file_path: Optional[str] = None, \n                           format: str = "json") -> bool:\n        """\n        Save plugin configuration to a file.\n        \n        Args:\n            plugin_name: Name of the plugin\n            file_path: Path to save the configuration. If None, uses default path.\n            format: Format to save in ("json" or "yaml")\n            \n        Returns:\n            True if successful, False otherwise\n        """\n        with self._config_lock:\n            config = self.get_plugin_config(plugin_name)\n            if not config:\n                self._logger.error(f"Plugin {plugin_name} configuration not found")\n                return False\n            \n            # Determine file path\n            if file_path is None:\n                file_path = str(self._config_dir / f"{plugin_name}_config.{format}")\n            \n            try:\n                config_data = config.to_dict()\n                \n                # Add metadata\n                config_with_metadata = {\n                    "plugin_name": plugin_name,\n                    "format_version": "1.0",\n                    "generated_at": __import__('time').time(),\n                    "configuration": config_data\n                }\n                \n                # Write to file\n                with open(file_path, 'w', encoding='utf-8') as f:\n                    if format.lower() == "json":\n                        json.dump(config_with_metadata, f, indent=2)\n                    elif format.lower() == "yaml":\n                        yaml.dump(config_with_metadata, f, default_flow_style=False)\n                    else:\n                        raise ValueError(f"Unsupported format: {format}")\n                \n                self._logger.info(f"Configuration saved for plugin {plugin_name} to {file_path}")\n                return True\n            except Exception as e:\n                self._logger.error(f"Error saving configuration for {plugin_name}: {e}")\n                return False\n\n    def load_config_from_file(self, plugin_name: str, file_path: str, \n                             format: Optional[str] = None) -> bool:\n        """\n        Load plugin configuration from a file.\n        \n        Args:\n            plugin_name: Name of the plugin\n            file_path: Path to load the configuration from\n            format: Format of the file ("json", "yaml", or None to auto-detect)\n            \n        Returns:\n            True if successful, False otherwise\n        """\n        with self._config_lock:\n            if format is None:\n                # Auto-detect format from file extension\n                if file_path.lower().endswith('.yaml') or file_path.lower().endswith('.yml'):\n                    format = "yaml"\n                else:\n                    format = "json"\n            \n            try:\n                # Read from file\n                with open(file_path, 'r', encoding='utf-8') as f:\n                    if format.lower() == "json":\n                        config_with_metadata = json.load(f)\n                    elif format.lower() == "yaml":\n                        config_with_metadata = yaml.safe_load(f)\n                    else:\n                        raise ValueError(f"Unsupported format: {format}")\n                \n                # Extract configuration\n                if "configuration" in config_with_metadata:\n                    config_data = config_with_metadata["configuration"]\n                else:\n                    # Assume the whole file is configuration\n                    config_data = config_with_metadata\n                \n                # Validate configuration\n                is_valid, error_msg = self.validate_config(plugin_name, config_data)\n                if not is_valid:\n                    self._logger.error(f"Configuration validation failed for {plugin_name}: {error_msg}")\n                    return False\n                \n                # Apply configuration\n                return self.set_plugin_config(plugin_name, config_data)\n                \n            except Exception as e:\n                self._logger.error(f"Error loading configuration for {plugin_name} from {file_path}: {e}")\n                return False\n\n    def save_all_configs(self, directory: Optional[str] = None, format: str = "json") -> Dict[str, bool]:\n        """\n        Save all plugin configurations to files.\n        \n        Args:\n            directory: Directory to save configs. If None, uses default.\n            format: Format to save in ("json" or "yaml")\n            \n        Returns:\n            Dictionary mapping plugin names to save success status\n        """\n        with self._config_lock:\n            results = {}\n            save_dir = Path(directory) if directory else self._config_dir\n            \n            # Ensure directory exists\n            save_dir.mkdir(parents=True, exist_ok=True)\n            \n            for plugin in self._registry.get_all_plugins():\n                plugin_name = plugin.get_metadata().name\n                file_path = str(save_dir / f"{plugin_name}_config.{format}")\n                results[plugin_name] = self.save_config_to_file(plugin_name, file_path, format)\n            \n            return results\n\n    def load_all_configs(self, directory: Optional[str] = None, format: Optional[str] = None) -> Dict[str, bool]:\n        """\n        Load all plugin configurations from files.\n        \n        Args:\n            directory: Directory to load configs from. If None, uses default.\n            format: Format of the files ("json", "yaml", or None to auto-detect)\n            \n        Returns:\n            Dictionary mapping plugin names to load success status\n        """\n        with self._config_lock:\n            results = {}\n            load_dir = Path(directory) if directory else self._config_dir\n            \n            if not load_dir.exists():\n                self._logger.warning(f"Configuration directory {load_dir} does not exist")\n                return results\n            \n            # Find all config files\n            pattern = f"*_config.json" if format == "json" or (format is None and not load_dir.glob("*_config.yaml")) else "*_config.yaml"\n            config_files = list(load_dir.glob(pattern))\n            \n            if not config_files and format is None:\n                # Try the other format\n                pattern = "*_config.yaml" if load_dir.glob("*_config.json") else "*_config.json"\n                config_files = list(load_dir.glob(pattern))\n            \n            for config_file in config_files:\n                # Extract plugin name from filename\n                file_name = config_file.name\n                if file_name.endswith("_config.json"):\n                    plugin_name = file_name[:-12]  # Remove "_config.json"\n                elif file_name.endswith("_config.yaml"):\n                    plugin_name = file_name[:-12]  # Remove "_config.yaml"\n                elif file_name.endswith("_config.yml"):\n                    plugin_name = file_name[:-11]  # Remove "_config.yml"\n                else:\n                    continue  # Skip non-config files\n                \n                results[plugin_name] = self.load_config_from_file(plugin_name, str(config_file), format)\n            \n            return results\n\n    def get_config_history(self, plugin_name: str) -> List[Dict[str, Any]]:\n        """\n        Get the configuration history for a plugin.\n        \n        Args:\n            plugin_name: Name of the plugin\n            \n        Returns:\n            List of historical configuration states\n        """\n        with self._config_lock:\n            return self._config_history.get(plugin_name, []).copy()\n\n    def _add_to_config_history(self, plugin_name: str, config_data: Dict[str, Any]) -> None:\n        """Add a configuration state to the history."""\n        if plugin_name not in self._config_history:\n            self._config_history[plugin_name] = []\n        \n        # Create a copy of the config data with a timestamp\n        history_entry = {\n            "timestamp": __import__('time').time(),\n            "config": config_data.copy(),\n            "hash": hashlib.md5(json.dumps(config_data, sort_keys=True).encode()).hexdigest()\n        }\n        \n        # Add to history\n        self._config_history[plugin_name].append(history_entry)\n        \n        # Keep only the last 10 configurations to prevent unbounded growth\n        if len(self._config_history[plugin_name]) > 10:\n            self._config_history[plugin_name] = self._config_history[plugin_name][-10:]\n\n    def reset_plugin_config(self, plugin_name: str) -> bool:\n        """\n        Reset a plugin's configuration to default values.\n        \n        Args:\n            plugin_name: Name of the plugin\n            \n        Returns:\n            True if successful, False otherwise\n        """\n        with self._config_lock:\n            plugin = self._registry.get_plugin(plugin_name)\n            if not plugin:\n                self._logger.error(f"Plugin {plugin_name} not found in registry")\n                return False\n            \n            # Get default configuration from metadata schema\n            schema = plugin.get_metadata().config_schema\n            if schema and "properties" in schema:\n                # Create default config based on schema\n                default_config = {}\n                for prop_name, prop_def in schema["properties"].items():\n                    if "default" in prop_def:\n                        default_config[prop_name] = prop_def["default"]\n                    elif prop_def.get("type") == "string":\n                        default_config[prop_name] = ""\n                    elif prop_def.get("type") == "number":\n                        default_config[prop_name] = 0\n                    elif prop_def.get("type") == "boolean":\n                        default_config[prop_name] = False\n                    elif prop_def.get("type") == "array":\n                        default_config[prop_name] = []\n                    elif prop_def.get("type") == "object":\n                        default_config[prop_name] = {}\n                \n                return self.set_plugin_config(plugin_name, default_config)\n            else:\n                # No schema, reset to empty config\n                return self.set_plugin_config(plugin_name, {})\n\n    def get_all_plugin_configs(self) -> Dict[str, Dict[str, Any]]:\n        """\n        Get configurations for all plugins.\n        \n        Returns:\n            Dictionary mapping plugin names to their configurations\n        """\n        with self._config_lock:\n            configs = {}\n            for plugin in self._registry.get_all_plugins():\n                plugin_name = plugin.get_metadata().name\n                config = self.get_plugin_config(plugin_name)\n                if config:\n                    configs[plugin_name] = config.to_dict()\n            return configs\n\n    def export_config_bundle(self, file_path: str, plugin_names: Optional[List[str]] = None) -> bool:\n        """\n        Export a bundle of plugin configurations to a single file.\n        \n        Args:\n            file_path: Path to save the configuration bundle\n            plugin_names: List of plugin names to include. If None, includes all.\n            \n        Returns:\n            True if successful, False otherwise\n        """\n        with self._config_lock:\n            try:\n                if plugin_names is None:\n                    plugin_names = [p.get_metadata().name for p in self._registry.get_all_plugins()]\n                \n                bundle = {\n                    "format_version": "1.0",\n                    "generated_at": __import__('time').time(),\n                    "plugins": {}\n                }\n                \n                for plugin_name in plugin_names:\n                    config = self.get_plugin_config(plugin_name)\n                    if config:\n                        bundle["plugins"][plugin_name] = {\n                            "config": config.to_dict(),\n                            "metadata": asdict(self._registry.get_plugin_metadata(plugin_name))\n                        }\n                \n                with open(file_path, 'w', encoding='utf-8') as f:\n                    json.dump(bundle, f, indent=2)\n                \n                self._logger.info(f"Configuration bundle saved to {file_path}")\n                return True\n            except Exception as e:\n                self._logger.error(f"Error exporting configuration bundle: {e}")\n                return False\n\n    def import_config_bundle(self, file_path: str, apply: bool = True) -> Dict[str, bool]:\n        """\n        Import a bundle of plugin configurations from a file.\n        \n        Args:\n            file_path: Path to the configuration bundle file\n            apply: Whether to apply the configurations to plugins (True) or just validate (False)\n            \n        Returns:\n            Dictionary mapping plugin names to import success status\n        """\n        with self._config_lock:\n            results = {}\n            \n            try:\n                with open(file_path, 'r', encoding='utf-8') as f:\n                    bundle = json.load(f)\n                \n                if "plugins" not in bundle:\n                    self._logger.error(f"Invalid bundle format in {file_path}")\n                    return results\n                \n                for plugin_name, plugin_data in bundle["plugins"].items():\n                    if "config" in plugin_data:\n                        config_data = plugin_data["config"]\n                        \n                        if apply:\n                            # Apply configuration to plugin\n                            results[plugin_name] = self.set_plugin_config(plugin_name, config_data)\n                        else:\n                            # Just validate the configuration\n                            is_valid, error_msg = self.validate_config(plugin_name, config_data)\n                            results[plugin_name] = is_valid\n                            if not is_valid:\n                                self._logger.error(f"Invalid config for {plugin_name}: {error_msg}")\n                    else:\n                        self._logger.warning(f"No config found for plugin {plugin_name} in bundle")\n                \n                if apply:\n                    self._logger.info(f"Configuration bundle imported from {file_path}")\n                else:\n                    self._logger.info(f"Configuration bundle validated from {file_path}")\n                \n                return results\n            except Exception as e:\n                self._logger.error(f"Error importing configuration bundle: {e}")\n                return results\n\n\n# Global configuration manager instance\nconfig_manager = PluginConfigurationManager()\n\n\ndef get_config_manager() -> PluginConfigurationManager:\n    """\n    Get the global plugin configuration manager instance.\n    \n    Returns:\n        PluginConfigurationManager instance\n    """\n    return config_manager