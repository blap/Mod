"""\nPlugin discovery and loading mechanisms for the optimization framework.\n\nThis module provides functionality for discovering, scanning, validating, and\nloading plugins from various sources.\n"""\n\nimport os\nimport sys\nimport importlib\nimport importlib.util\nimport json\nfrom typing import Dict, List, Optional, Any, Tuple, Callable\nfrom pathlib import Path\nimport ast\nimport inspect\nfrom dataclasses import dataclass\nimport logging\nimport hashlib\nimport threading\n\nfrom plugin_system.core import IPlugin, PluginType, PluginState, PluginMetadata, BasePlugin, IOptimizationPlugin, IMemoryManagementPlugin, IAttentionPlugin, ICPUPlugin, IPowerManagementPlugin, IThermalManagementPlugin, ICacheManagementPlugin, IModelOptimizationPlugin\n    IPlugin, PluginType, PluginState, PluginMetadata, BasePlugin,\n    IOptimizationPlugin, IMemoryManagementPlugin, IAttentionPlugin,\n    ICPUPlugin, IPowerManagementPlugin, IThermalManagementPlugin,\n    ICacheManagementPlugin, IModelOptimizationPlugin\n)\nfrom plugin_system.registry import PluginRegistry, get_plugin_registry\nfrom plugin_system.lifecycle import PluginLifecycleManager, get_lifecycle_manager\n\n\n@dataclass\nclass PluginDiscoveryResult:\n    """Result of a plugin discovery operation."""\n    plugin_path: str\n    plugin_name: str\n    plugin_class_name: str\n    metadata: Optional[PluginMetadata]\n    is_valid: bool\n    error_message: Optional[str] = None\n    dependencies: List[str] = None\n    compatibility: List[str] = None\n\n\nclass PluginDiscovery:\n    """\n    Discovers plugins in the filesystem and validates them for loading.\n    """\n    \n    def __init__(self, registry: Optional[PluginRegistry] = None):\n        """\n        Initialize the plugin discovery system.\n        \n        Args:\n            registry: Optional plugin registry to use. If None, uses global registry.\n        """\n        self._registry = registry or get_plugin_registry()\n        self._logger = logging.getLogger(f"{self.__class__.__module__}.{self.__class__.__name__}")\n        self._discovery_lock = threading.Lock()\n\n    def discover_plugins_in_directory(self, directory_path: str, recursive: bool = True) -> List[PluginDiscoveryResult]:\n        """\n        Discover plugins in a directory.\n        \n        Args:\n            directory_path: Path to the directory to search\n            recursive: Whether to search subdirectories\n            \n        Returns:\n            List of discovery results\n        """\n        results = []\n        path = Path(directory_path)\n        \n        if not path.exists() or not path.is_dir():\n            self._logger.error(f"Directory {directory_path} does not exist or is not a directory")\n            return results\n        \n        # Find all Python files in the directory\n        pattern = "**/*.py" if recursive else "*.py"\n        py_files = list(path.glob(pattern))\n        \n        for py_file in py_files:\n            if py_file.name.startswith('__'):\n                continue  # Skip __init__.py and similar files\n            \n            result = self.discover_plugin_in_file(str(py_file))\n            if result:\n                results.append(result)\n        \n        return results\n\n    def discover_plugin_in_file(self, file_path: str) -> Optional[PluginDiscoveryResult]:\n        """\n        Discover a plugin in a single Python file.\n        \n        Args:\n            file_path: Path to the Python file\n            \n        Returns:\n            Discovery result if a plugin is found, None otherwise\n        """\n        try:\n            # Parse the file to find plugin classes without importing\n            with open(file_path, 'r', encoding='utf-8') as f:\n                file_content = f.read()\n            \n            tree = ast.parse(file_content)\n            \n            # Look for classes that inherit from IPlugin or BasePlugin\n            for node in ast.walk(tree):\n                if isinstance(node, ast.ClassDef):\n                    for base in node.bases:\n                        if isinstance(base, ast.Name) and base.id in ['IPlugin', 'BasePlugin']:\n                            # Found a potential plugin class\n                            plugin_name = self._extract_plugin_name(file_content, node.name)\n                            metadata = self._extract_metadata_from_source(file_content, node.name)\n                            \n                            return PluginDiscoveryResult(\n                                plugin_path=file_path,\n                                plugin_name=plugin_name or node.name,\n                                plugin_class_name=node.name,\n                                metadata=metadata,\n                                is_valid=self._validate_plugin_source(file_content, node.name),\n                                error_message=None,\n                                dependencies=metadata.dependencies if metadata else [],\n                                compatibility=metadata.compatibility if metadata else []\n                            )\n                        elif (isinstance(base, ast.Attribute) and \n                              isinstance(base.value, ast.Name) and \n                              base.value.id == 'plugin_system' and \n                              base.attr in ['IPlugin', 'BasePlugin']):\n                            # Handle qualified imports like plugin_system.core.IPlugin\n                            plugin_name = self._extract_plugin_name(file_content, node.name)\n                            metadata = self._extract_metadata_from_source(file_content, node.name)\n                            \n                            return PluginDiscoveryResult(\n                                plugin_path=file_path,\n                                plugin_name=plugin_name or node.name,\n                                plugin_class_name=node.name,\n                                metadata=metadata,\n                                is_valid=self._validate_plugin_source(file_content, node.name),\n                                error_message=None,\n                                dependencies=metadata.dependencies if metadata else [],\n                                compatibility=metadata.compatibility if metadata else []\n                            )\n            \n            # If no plugin class found, return None\n            return None\n            \n        except Exception as e:\n            self._logger.error(f"Error discovering plugin in {file_path}: {e}")\n            return PluginDiscoveryResult(\n                plugin_path=file_path,\n                plugin_name=Path(file_path).stem,\n                plugin_class_name="",\n                metadata=None,\n                is_valid=False,\n                error_message=str(e),\n                dependencies=[],\n                compatibility=[]\n            )\n\n    def _extract_plugin_name(self, source_code: str, class_name: str) -> Optional[str]:\n        """Extract plugin name from source code by looking for metadata assignments."""\n        try:\n            # Look for metadata assignments in the class\n            lines = source_code.split('\n')\n            in_class = False\n            class_indent = 0\n            \n            for line in lines:\n                stripped = line.strip()\n                \n                # Check if we're entering the target class\n                if stripped.startswith(f'class {class_name}'):\n                    in_class = True\n                    class_indent = len(line) - len(line.lstrip())\n                    continue\n                \n                # Check if we're exiting the class\n                if in_class and line.strip() and len(line) - len(line.lstrip()) <= class_indent:\n                    in_class = False\n                    continue\n                \n                # Look for metadata.name assignment in the class\n                if in_class and 'self._metadata.name' in line and '=' in line:\n                    # This is a simple heuristic - in a real implementation, \n                    # we'd need more sophisticated AST analysis\n                    parts = line.split('=')\n                    if len(parts) > 1:\n                        value = parts[1].strip().strip('"\'')\n                        if value:\n                            return value\n            \n            # If not found in the class, return class name as default\n            return class_name\n        except:\n            return class_name\n\n    def _extract_metadata_from_source(self, source_code: str, class_name: str) -> Optional[PluginMetadata]:\n        """Extract metadata from source code."""\n        try:\n            # This is a simplified approach - in a real implementation,\n            # we would use more sophisticated AST analysis\n            if 'PluginMetadata' in source_code:\n                # Look for PluginMetadata initialization\n                lines = source_code.split('\n')\n                for i, line in enumerate(lines):\n                    if 'PluginMetadata(' in line:\n                        # This is a simplified extraction - real implementation\n                        # would parse the actual constructor call\n                        continue\n            \n            # For now, return a basic metadata object\n            # In a real implementation, we'd extract actual values from source\n            return PluginMetadata(\n                name=class_name,\n                version="1.0.0",\n                description=f"Plugin {class_name}",\n                author="Unknown",\n                plugin_type=PluginType.CUSTOM,\n                dependencies=[],\n                compatibility=["1.0.0"]\n            )\n        except:\n            return None\n\n    def _validate_plugin_source(self, source_code: str, class_name: str) -> bool:\n        """Validate that the plugin source code is valid."""\n        try:\n            # Check that the class implements required methods\n            required_methods = ['initialize', 'activate', 'deactivate', 'get_metadata', 'get_config']\n            \n            for method in required_methods:\n                if f'def {method}(' in source_code:\n                    continue  # Found the method\n                else:\n                    # Check if it's in a parent class (simplified check)\n                    if 'BasePlugin' in source_code or 'IPlugin' in source_code:\n                        continue  # Assume it inherits the methods\n                    else:\n                        return False  # Missing required method\n            \n            return True\n        except:\n            return False\n\n    def scan_for_plugins(self, search_paths: List[str], recursive: bool = True) -> List[PluginDiscoveryResult]:\n        """\n        Scan multiple directories for plugins.\n        \n        Args:\n            search_paths: List of directories to search\n            recursive: Whether to search subdirectories\n            \n        Returns:\n            List of discovery results from all paths\n        """\n        all_results = []\n        \n        for path in search_paths:\n            results = self.discover_plugins_in_directory(path, recursive)\n            all_results.extend(results)\n        \n        return all_results\n\n    def validate_plugin_file(self, file_path: str) -> Tuple[bool, Optional[str]]:\n        """\n        Validate a plugin file for correctness.\n        \n        Args:\n            file_path: Path to the plugin file\n            \n        Returns:\n            Tuple of (is_valid, error_message)\n        """\n        try:\n            # Check if file exists\n            if not os.path.exists(file_path):\n                return False, f"File {file_path} does not exist"\n            \n            # Check if it's a Python file\n            if not file_path.endswith('.py'):\n                return False, f"File {file_path} is not a Python file"\n            \n            # Parse the file to check for syntax errors\n            with open(file_path, 'r', encoding='utf-8') as f:\n                source_code = f.read()\n            \n            try:\n                ast.parse(source_code)\n            except SyntaxError as e:\n                return False, f"Syntax error in {file_path}: {e}"\n            \n            # Import the module temporarily to check for import errors\n            spec = importlib.util.spec_from_file_location("temp_plugin_module", file_path)\n            if spec is None or spec.loader is None:\n                return False, f"Could not create module spec for {file_path}"\n            \n            temp_module = importlib.util.module_from_spec(spec)\n            \n            # Execute the module to check for runtime errors during import\n            try:\n                spec.loader.exec_module(temp_module)\n            except Exception as e:\n                return False, f"Runtime error during import of {file_path}: {e}"\n            \n            # Check if the module contains a plugin class\n            plugin_class_found = False\n            for attr_name in dir(temp_module):\n                attr = getattr(temp_module, attr_name)\n                if (isinstance(attr, type) and \n                    issubclass(attr, IPlugin) and \n                    attr != BasePlugin and \n                    attr.__module__ == temp_module.__name__):\n                    plugin_class_found = True\n                    break\n            \n            if not plugin_class_found:\n                return False, f"No plugin class found in {file_path}"\n            \n            return True, None\n            \n        except Exception as e:\n            return False, f"Validation error for {file_path}: {e}"\n\n    def get_plugin_info_from_file(self, file_path: str) -> Optional[Dict[str, Any]]:\n        """\n        Extract plugin information from a file without loading it.\n        \n        Args:\n            file_path: Path to the plugin file\n            \n        Returns:\n            Dictionary with plugin information or None if extraction fails\n        """\n        try:\n            with open(file_path, 'r', encoding='utf-8') as f:\n                source_code = f.read()\n            \n            # Parse the source code\n            tree = ast.parse(source_code)\n            \n            # Look for plugin class definitions\n            for node in ast.walk(tree):\n                if isinstance(node, ast.ClassDef):\n                    for base in node.bases:\n                        base_name = None\n                        if isinstance(base, ast.Name):\n                            base_name = base.id\n                        elif isinstance(base, ast.Attribute):\n                            base_name = base.attr  # For qualified names like plugin_system.core.IPlugin\n                        \n                        if base_name in ['IPlugin', 'BasePlugin', 'IOptimizationPlugin', \n                                       'IMemoryManagementPlugin', 'IAttentionPlugin',\n                                       'ICPUPlugin', 'IPowerManagementPlugin', \n                                       'IThermalManagementPlugin', 'ICacheManagementPlugin',\n                                       'IModelOptimizationPlugin']:\n                            # Found a plugin class, extract information\n                            info = {\n                                'class_name': node.name,\n                                'file_path': file_path,\n                                'methods': [],\n                                'properties': []\n                            }\n                            \n                            # Extract methods and properties\n                            for item in node.body:\n                                if isinstance(item, ast.FunctionDef):\n                                    info['methods'].append(item.name)\n                                elif isinstance(item, ast.Assign):\n                                    for target in item.targets:\n                                        if isinstance(target, ast.Name):\n                                            info['properties'].append(target.id)\n                            \n                            return info\n            \n            return None\n            \n        except Exception as e:\n            self._logger.error(f"Error extracting plugin info from {file_path}: {e}")\n            return None\n\n\nclass PluginLoader:\n    """\n    Loads and instantiates plugins from various sources.\n    """\n    \n    def __init__(self, \n                 registry: Optional[PluginRegistry] = None, \n                 lifecycle_manager: Optional[PluginLifecycleManager] = None):\n        """\n        Initialize the plugin loader.\n        \n        Args:\n            registry: Optional plugin registry to use. If None, uses global registry.\n            lifecycle_manager: Optional lifecycle manager to use. If None, uses global manager.\n        """\n        self._registry = registry or get_plugin_registry()\n        self._lifecycle_manager = lifecycle_manager or get_lifecycle_manager()\n        self._logger = logging.getLogger(f"{self.__class__.__module__}.{self.__class__.__name__}")\n        self._loader_lock = threading.Lock()\n\n    def load_plugin_from_file(self, file_path: str, config_data: Optional[Dict[str, Any]] = None) -> Optional[str]:\n        """\n        Load a plugin from a file using the registry.\n        \n        Args:\n            file_path: Path to the plugin file\n            config_data: Optional configuration data for the plugin\n            \n        Returns:\n            Plugin name if successful, None otherwise\n        """\n        return self._lifecycle_manager.load_plugin(file_path, config_data)\n\n    def load_plugins_from_directory(self, directory_path: str, recursive: bool = True) -> List[str]:\n        """\n        Load all plugins from a directory.\n        \n        Args:\n            directory_path: Path to the directory containing plugin files\n            recursive: Whether to search subdirectories\n            \n        Returns:\n            List of successfully loaded plugin names\n        """\n        return self._lifecycle_manager.load_plugins_from_directory(directory_path, recursive)\n\n    def load_plugin_from_module(self, module_path: str, class_name: str, \n                               config_data: Optional[Dict[str, Any]] = None) -> Optional[str]:\n        """\n        Load a plugin from a Python module.\n        \n        Args:\n            module_path: Path to the module (e.g., "myplugin.core")\n            class_name: Name of the plugin class in the module\n            config_data: Optional configuration data for the plugin\n            \n        Returns:\n            Plugin name if successful, None otherwise\n        """\n        with self._loader_lock:\n            try:\n                # Import the module\n                module = importlib.import_module(module_path)\n                \n                # Get the plugin class\n                plugin_class = getattr(module, class_name)\n                \n                # Verify it's a plugin class\n                if not (isinstance(plugin_class, type) and issubclass(plugin_class, IPlugin)):\n                    self._logger.error(f"{class_name} is not a valid plugin class")\n                    return None\n                \n                # Create an instance\n                plugin_instance = plugin_class()\n                \n                # Register the plugin\n                if self._registry.register_plugin(plugin_instance):\n                    # Initialize with config\n                    config = plugin_instance.get_config()\n                    if config_data:\n                        config.update(config_data)\n                    \n                    if plugin_instance.initialize(config):\n                        return plugin_instance.get_metadata().name\n                    else:\n                        self._logger.error(f"Failed to initialize plugin {class_name}")\n                        # Unregister if initialization failed\n                        self._registry.unregister_plugin(plugin_instance.get_metadata().name)\n                        return None\n                else:\n                    self._logger.error(f"Failed to register plugin {class_name}")\n                    return None\n                    \n            except Exception as e:\n                self._logger.error(f"Error loading plugin {class_name} from module {module_path}: {e}")\n                return None\n\n    def load_plugin_from_source(self, source_code: str, plugin_name: str,\n                               config_data: Optional[Dict[str, Any]] = None) -> Optional[str]:\n        """\n        Load a plugin from source code string.\n        \n        Args:\n            source_code: Source code of the plugin\n            plugin_name: Name to assign to the plugin\n            config_data: Optional configuration data for the plugin\n            \n        Returns:\n            Plugin name if successful, None otherwise\n        """\n        with self._loader_lock:\n            try:\n                # Create a temporary file with the source code\n                import tempfile\n                with tempfile.NamedTemporaryFile(mode='w', suffix='.py', delete=False) as f:\n                    f.write(source_code)\n                    temp_file_path = f.name\n                \n                try:\n                    # Load from the temporary file\n                    result = self.load_plugin_from_file(temp_file_path, config_data)\n                    return result\n                finally:\n                    # Clean up the temporary file\n                    os.unlink(temp_file_path)\n                    \n            except Exception as e:\n                self._logger.error(f"Error loading plugin from source: {e}")\n                return None\n\n    def load_plugins_from_manifest(self, manifest_path: str) -> List[str]:\n        """\n        Load plugins based on a manifest file.\n        \n        Args:\n            manifest_path: Path to the manifest file (JSON format)\n            \n        Returns:\n            List of successfully loaded plugin names\n        """\n        loaded_plugins = []\n        \n        try:\n            with open(manifest_path, 'r', encoding='utf-8') as f:\n                manifest = json.load(f)\n            \n            # Validate manifest structure\n            if not isinstance(manifest, dict) or 'plugins' not in manifest:\n                self._logger.error(f"Invalid manifest format in {manifest_path}")\n                return loaded_plugins\n            \n            for plugin_info in manifest['plugins']:\n                if not isinstance(plugin_info, dict):\n                    continue\n                \n                plugin_path = plugin_info.get('path')\n                plugin_config = plugin_info.get('config', {})\n                \n                if plugin_path:\n                    # Normalize the path relative to the manifest file\n                    manifest_dir = Path(manifest_path).parent\n                    full_path = manifest_dir / plugin_path\n                    full_path = full_path.resolve()\n                    \n                    plugin_name = self.load_plugin_from_file(str(full_path), plugin_config)\n                    if plugin_name:\n                        loaded_plugins.append(plugin_name)\n        \n        except Exception as e:\n            self._logger.error(f"Error loading plugins from manifest {manifest_path}: {e}")\n        \n        return loaded_plugins\n\n    def load_plugins_with_dependencies(self, plugin_paths: List[str], \n                                     config_overrides: Optional[Dict[str, Dict[str, Any]]] = None) -> Dict[str, bool]:\n        """\n        Load plugins while respecting dependencies.\n        \n        Args:\n            plugin_paths: List of plugin file paths to load\n            config_overrides: Optional dictionary mapping plugin names to config overrides\n            \n        Returns:\n            Dictionary mapping plugin names to loading success status\n        """\n        results = {}\n        config_overrides = config_overrides or {}\n        \n        # First, discover all plugins to understand dependencies\n        discovery = PluginDiscovery(self._registry)\n        all_discovery_results = []\n        \n        for path in plugin_paths:\n            result = discovery.discover_plugin_in_file(path)\n            if result:\n                all_discovery_results.append(result)\n        \n        # Build dependency graph\n        dep_graph = {}\n        plugin_map = {}  # Maps plugin name to file path\n        \n        for result in all_discovery_results:\n            if result.is_valid and result.metadata:\n                plugin_map[result.plugin_name] = result.plugin_path\n                dep_graph[result.plugin_name] = result.dependencies or []\n        \n        # Sort plugins by dependency order\n        sorted_plugins = self._topological_sort(list(dep_graph.keys()), dep_graph)\n        \n        # Load plugins in dependency order\n        for plugin_name in sorted_plugins:\n            if plugin_name in plugin_map:\n                config = config_overrides.get(plugin_name, {})\n                result = self.load_plugin_from_file(plugin_map[plugin_name], config)\n                results[plugin_name] = result is not None\n        \n        return results\n\n    def _topological_sort(self, nodes: List[str], dependencies: Dict[str, List[str]]) -> List[str]:\n        """\n        Perform topological sort on plugins based on dependencies.\n        \n        Args:\n            nodes: List of plugin names\n            dependencies: Dictionary mapping plugin names to their dependencies\n            \n        Returns:\n            List of plugin names in dependency order\n        """\n        # Build adjacency list\n        graph = {node: [] for node in nodes}\n        for node, deps in dependencies.items():\n            for dep in deps:\n                if dep in graph:\n                    graph[dep].append(node)  # dep -> node (node depends on dep)\n        \n        # Perform topological sort\n        result = []\n        visited = set()\n        temp = set()\n        \n        def visit(node):\n            if node in temp:\n                raise ValueError(f"Circular dependency detected involving {node}")\n            if node in visited:\n                return\n            temp.add(node)\n            for neighbor in graph[node]:\n                visit(neighbor)\n            temp.remove(node)\n            visited.add(node)\n            result.append(node)\n        \n        for node in nodes:\n            if node not in visited:\n                visit(node)\n        \n        return result\n\n\n# Global discovery and loader instances\ndiscovery = PluginDiscovery()\nloader = PluginLoader()\n\n\ndef get_plugin_discovery() -> PluginDiscovery:\n    """\n    Get the global plugin discovery instance.\n    \n    Returns:\n        PluginDiscovery instance\n    """\n    return discovery\n\n\ndef get_plugin_loader() -> PluginLoader:\n    """\n    Get the global plugin loader instance.\n    \n    Returns:\n        PluginLoader instance\n    """\n    return loader