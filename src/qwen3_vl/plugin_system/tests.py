"""\nComprehensive tests for the plugin system.\n\nThis module contains unit and integration tests for all components\nof the plugin system.\n"""\n\nimport unittest\nimport tempfile\nimport os\nfrom pathlib import Path\nimport json\nimport threading\nfrom typing import Dict, List, Optional, Any\n\nfrom plugin_system.core import IPlugin, PluginType, PluginState, PluginMetadata, PluginConfig, BasePlugin, IOptimizationPlugin, IMemoryManagementPlugin, IAttentionPlugin, ICPUPlugin, IPowerManagementPlugin, IThermalManagementPlugin, ICacheManagementPlugin, IModelOptimizationPlugin\n    IPlugin, PluginType, PluginState, PluginMetadata, PluginConfig, BasePlugin,\n    IOptimizationPlugin, IMemoryManagementPlugin, IAttentionPlugin,\n    ICPUPlugin, IPowerManagementPlugin, IThermalManagementPlugin,\n    ICacheManagementPlugin, IModelOptimizationPlugin\n)\nfrom plugin_system.registry import PluginRegistry, get_plugin_registry\nfrom plugin_system.lifecycle import PluginLifecycleManager, get_lifecycle_manager\nfrom plugin_system.discovery import PluginDiscovery, PluginLoader, get_plugin_discovery, get_plugin_loader\nfrom plugin_system.config import PluginConfigurationManager, get_config_manager\nfrom plugin_system.validation import PluginValidator, PluginTester, get_plugin_validator, get_plugin_tester\nfrom plugin_system.compatibility import LegacyPluginWrapper, CompatibilityLayer, get_compatibility_layer\n\n\nclass TestPlugin(BasePlugin):\n    """Test plugin implementation for testing purposes."""\n    \n    def __init__(self):\n        metadata = PluginMetadata(\n            name="test_plugin",\n            version="1.0.0",\n            description="Test plugin for unit testing",\n            author="Test Author",\n            plugin_type=PluginType.CUSTOM,\n            dependencies=[],\n            compatibility=["1.0.0"]\n        )\n        super().__init__(metadata)\n        self._activation_count = 0\n        self._deactivation_count = 0\n\n    def activate(self) -> bool:\n        result = super().activate()\n        if result:\n            self._activation_count += 1\n        return result\n\n    def deactivate(self) -> bool:\n        result = super().deactivate()\n        if result:\n            self._deactivation_count += 1\n        return result\n\n\nclass TestOptimizationPlugin(BasePlugin, IOptimizationPlugin):\n    """Test optimization plugin implementation."""\n    \n    def __init__(self):\n        metadata = PluginMetadata(\n            name="test_optimization_plugin",\n            version="1.0.0",\n            description="Test optimization plugin",\n            author="Test Author",\n            plugin_type=PluginType.OPTIMIZATION,\n            dependencies=[],\n            compatibility=["1.0.0"]\n        )\n        super().__init__(metadata)\n        self.optimization_calls = 0\n\n    def optimize(self, *args, **kwargs):\n        self.optimization_calls += 1\n        return f"optimized_{args[0] if args else 'default'}"\n\n    def activate(self) -> bool:\n        return super().activate()\n\n    def deactivate(self) -> bool:\n        return super().deactivate()\n\n\nclass TestMemoryPlugin(BasePlugin, IMemoryManagementPlugin):\n    """Test memory management plugin implementation."""\n    \n    def __init__(self):\n        metadata = PluginMetadata(\n            name="test_memory_plugin",\n            version="1.0.0",\n            description="Test memory management plugin",\n            author="Test Author",\n            plugin_type=PluginType.MEMORY_MANAGEMENT,\n            dependencies=[],\n            compatibility=["1.0.0"]\n        )\n        super().__init__(metadata)\n        self.allocated_blocks = {}\n\n    def allocate_memory(self, size: int, hints: Optional[Dict[str, Any]] = None):\n        block_id = f"block_{len(self.allocated_blocks) + 1}"\n        self.allocated_blocks[block_id] = size\n        return block_id\n\n    def free_memory(self, memory_handle: Any) -> bool:\n        if memory_handle in self.allocated_blocks:\n            del self.allocated_blocks[memory_handle]\n            return True\n        return False\n\n    def activate(self) -> bool:\n        return super().activate()\n\n    def deactivate(self) -> bool:\n        return super().deactivate()\n\n\nclass TestCore(unittest.TestCase):\n    """Tests for the core plugin system components."""\n    \n    def test_plugin_metadata_creation(self):\n        """Test creating plugin metadata."""\n        metadata = PluginMetadata(\n            name="test",\n            version="1.0.0",\n            description="Test plugin",\n            author="Test Author",\n            plugin_type=PluginType.CUSTOM,\n            dependencies=[],\n            compatibility=["1.0.0"]\n        )\n        \n        self.assertEqual(metadata.name, "test")\n        self.assertEqual(metadata.version, "1.0.0")\n        self.assertEqual(metadata.description, "Test plugin")\n        self.assertEqual(metadata.plugin_type, PluginType.CUSTOM)\n        self.assertEqual(metadata.dependencies, [])\n        self.assertEqual(metadata.compatibility, ["1.0.0"])\n\n    def test_plugin_config(self):\n        """Test plugin configuration."""\n        config = PluginConfig("test_plugin", {"param1": "value1", "param2": 42})\n        \n        self.assertEqual(config.get("param1"), "value1")\n        self.assertEqual(config.get("param2"), 42)\n        self.assertEqual(config.get("nonexistent", "default"), "default")\n        \n        config.set("param3", "new_value")\n        self.assertEqual(config.get("param3"), "new_value")\n        \n        config.update({"param1": "updated", "param4": "added"})\n        self.assertEqual(config.get("param1"), "updated")\n        self.assertEqual(config.get("param4"), "added")\n        \n        config_dict = config.to_dict()\n        self.assertIn("param1", config_dict)\n        self.assertIn("param2", config_dict)\n        self.assertIn("param3", config_dict)\n        self.assertIn("param4", config_dict)\n\n    def test_base_plugin_lifecycle(self):\n        """Test base plugin lifecycle methods."""\n        plugin = TestPlugin()\n        \n        # Initially should be UNLOADED\n        self.assertEqual(plugin.state, PluginState.UNLOADED)\n        \n        # Initialize\n        config = PluginConfig("test_plugin")\n        self.assertTrue(plugin.initialize(config))\n        self.assertEqual(plugin.state, PluginState.INITIALIZED)\n        \n        # Activate\n        self.assertTrue(plugin.activate())\n        self.assertEqual(plugin.state, PluginState.ACTIVE)\n        \n        # Deactivate\n        self.assertTrue(plugin.deactivate())\n        self.assertEqual(plugin.state, PluginState.INACTIVE)\n        \n        # Reactivate\n        self.assertTrue(plugin.activate())\n        self.assertEqual(plugin.state, PluginState.ACTIVE)\n        \n        # Check that activation/deactivation counts are correct\n        self.assertEqual(plugin._activation_count, 2)\n        self.assertEqual(plugin._deactivation_count, 1)\n\n    def test_specific_plugin_interfaces(self):\n        """Test specific plugin interface implementations."""\n        # Test optimization plugin\n        opt_plugin = TestOptimizationPlugin()\n        self.assertIsInstance(opt_plugin, IOptimizationPlugin)\n        self.assertEqual(opt_plugin.optimize("test"), "optimized_test")\n        self.assertEqual(opt_plugin.optimization_calls, 1)\n        \n        # Test memory plugin\n        mem_plugin = TestMemoryPlugin()\n        self.assertIsInstance(mem_plugin, IMemoryManagementPlugin)\n        \n        block_id = mem_plugin.allocate_memory(1024)\n        self.assertIn(block_id, mem_plugin.allocated_blocks)\n        self.assertTrue(mem_plugin.free_memory(block_id))\n        self.assertNotIn(block_id, mem_plugin.allocated_blocks)\n\n\nclass TestRegistry(unittest.TestCase):\n    """Tests for the plugin registry."""\n    \n    def setUp(self):\n        """Set up test fixtures."""\n        self.registry = PluginRegistry()\n        # Clear any existing plugins\n        for plugin_name in list(self.registry._plugins.keys()):\n            self.registry.unregister_plugin(plugin_name)\n\n    def test_register_and_unregister_plugin(self):\n        """Test registering and unregistering plugins."""\n        plugin = TestPlugin()\n        \n        # Register plugin\n        self.assertTrue(self.registry.register_plugin(plugin))\n        self.assertIn("test_plugin", self.registry._plugins)\n        self.assertEqual(len(self.registry._plugin_types[PluginType.CUSTOM]), 1)\n        \n        # Try to register the same plugin again (should replace)\n        self.assertTrue(self.registry.register_plugin(plugin))\n        \n        # Unregister plugin\n        self.assertTrue(self.registry.unregister_plugin("test_plugin"))\n        self.assertNotIn("test_plugin", self.registry._plugins)\n        \n        # Try to unregister non-existent plugin\n        self.assertFalse(self.registry.unregister_plugin("nonexistent"))\n\n    def test_get_plugin_by_type(self):\n        """Test getting plugins by type."""\n        opt_plugin = TestOptimizationPlugin()\n        mem_plugin = TestMemoryPlugin()\n        \n        self.registry.register_plugin(opt_plugin)\n        self.registry.register_plugin(mem_plugin)\n        \n        opt_plugins = self.registry.get_plugins_by_type(PluginType.OPTIMIZATION)\n        mem_plugins = self.registry.get_plugins_by_type(PluginType.MEMORY_MANAGEMENT)\n        \n        self.assertEqual(len(opt_plugins), 1)\n        self.assertEqual(len(mem_plugins), 1)\n        self.assertIsInstance(opt_plugins[0], IOptimizationPlugin)\n        self.assertIsInstance(mem_plugins[0], IMemoryManagementPlugin)\n\n    def test_plugin_dependencies(self):\n        """Test plugin dependency management."""\n        # Create plugins with dependencies\n        metadata1 = PluginMetadata(\n            name="plugin1",\n            version="1.0.0",\n            description="First plugin",\n            author="Test",\n            plugin_type=PluginType.CUSTOM,\n            dependencies=[],\n            compatibility=["1.0.0"]\n        )\n        plugin1 = BasePlugin(metadata1)\n        \n        metadata2 = PluginMetadata(\n            name="plugin2",\n            version="1.0.0",\n            description="Second plugin",\n            author="Test",\n            plugin_type=PluginType.CUSTOM,\n            dependencies=["plugin1"],\n            compatibility=["1.0.0"]\n        )\n        plugin2 = BasePlugin(metadata2)\n        \n        self.registry.register_plugin(plugin1)\n        self.registry.register_plugin(plugin2)\n        \n        # Check dependencies are registered correctly\n        self.assertIn("plugin1", self.registry._dependencies["plugin2"])\n        self.assertIn("plugin2", self.registry._dependents["plugin1"])\n        \n        # Try to unregister plugin1 (should fail due to dependency)\n        self.assertFalse(self.registry.unregister_plugin("plugin1"))\n        \n        # Unregister plugin2 first, then plugin1\n        self.assertTrue(self.registry.unregister_plugin("plugin2"))\n        self.assertTrue(self.registry.unregister_plugin("plugin1"))\n\n\nclass TestLifecycle(unittest.TestCase):\n    """Tests for the plugin lifecycle manager."""\n    \n    def setUp(self):\n        """Set up test fixtures."""\n        self.registry = PluginRegistry()\n        self.lifecycle_manager = PluginLifecycleManager(self.registry)\n\n    def test_lifecycle_management(self):\n        """Test plugin lifecycle management."""\n        plugin = TestPlugin()\n        self.registry.register_plugin(plugin)\n        \n        # Initialize plugin\n        config = PluginConfig("test_plugin")\n        self.assertTrue(self.lifecycle_manager.initialize_plugin("test_plugin", config))\n        self.assertEqual(plugin.state, PluginState.INITIALIZED)\n        \n        # Activate plugin\n        self.assertTrue(self.lifecycle_manager.activate_plugin("test_plugin"))\n        self.assertEqual(plugin.state, PluginState.ACTIVE)\n        \n        # Deactivate plugin\n        self.assertTrue(self.lifecycle_manager.deactivate_plugin("test_plugin"))\n        self.assertEqual(plugin.state, PluginState.INACTIVE)\n        \n        # Get lifecycle status\n        status = self.lifecycle_manager.get_lifecycle_status()\n        self.assertIn("test_plugin", status)\n        self.assertEqual(status["test_plugin"], "inactive")\n\n    def test_dependency_handling(self):\n        """Test dependency handling in lifecycle."""\n        # Create plugins with dependencies\n        metadata1 = PluginMetadata(\n            name="dep_plugin",\n            version="1.0.0",\n            description="Dependency plugin",\n            author="Test",\n            plugin_type=PluginType.CUSTOM,\n            dependencies=[],\n            compatibility=["1.0.0"]\n        )\n        dep_plugin = BasePlugin(metadata1)\n\n        metadata2 = PluginMetadata(\n            name="main_plugin",\n            version="1.0.0",\n            description="Main plugin",\n            author="Test",\n            plugin_type=PluginType.CUSTOM,\n            dependencies=["dep_plugin"],\n            compatibility=["1.0.0"]\n        )\n        main_plugin = BasePlugin(metadata2)\n\n        self.registry.register_plugin(dep_plugin)\n        self.registry.register_plugin(main_plugin)\n\n        # Initialize both plugins\n        dep_config = PluginConfig("dep_plugin")\n        main_config = PluginConfig("main_plugin")\n        dep_plugin.initialize(dep_config)\n        main_plugin.initialize(main_config)\n\n        # Manually activate the dependency first\n        self.assertTrue(self.lifecycle_manager.activate_plugin("dep_plugin"))\n\n        # Now activating main plugin should succeed\n        self.assertTrue(self.lifecycle_manager.activate_plugin("main_plugin"))\n        self.assertEqual(dep_plugin.state, PluginState.ACTIVE)\n        self.assertEqual(main_plugin.state, PluginState.ACTIVE)\n\n        # Deactivating main plugin should not deactivate dependency\n        # (since dependency might be used by other plugins)\n        self.assertTrue(self.lifecycle_manager.deactivate_plugin("main_plugin"))\n        self.assertEqual(main_plugin.state, PluginState.INACTIVE)\n        self.assertEqual(dep_plugin.state, PluginState.ACTIVE)  # Dependency stays active\n\n\nclass TestDiscovery(unittest.TestCase):\n    """Tests for the plugin discovery system."""\n    \n    def setUp(self):\n        """Set up test fixtures."""\n        self.registry = PluginRegistry()\n        self.discovery = PluginDiscovery(self.registry)\n\n    def test_plugin_discovery_in_file(self):\n        """Test discovering plugins in a file."""\n        # Create a temporary plugin file\n        with tempfile.NamedTemporaryFile(mode='w', suffix='.py', delete=False) as f:\n            f.write("""\nfrom plugin_system.core import BasePlugin, PluginMetadata, PluginType\n\nclass DiscoveredTestPlugin(BasePlugin):\n    def __init__(self):\n        metadata = PluginMetadata(\n            name="discovered_plugin",\n            version="1.0.0",\n            description="Discovered test plugin",\n            author="Test",\n            plugin_type=PluginType.CUSTOM,\n            dependencies=[],\n            compatibility=["1.0.0"]\n        )\n        super().__init__(metadata)\n""")\n            temp_file_path = f.name\n\n        try:\n            # Discover the plugin\n            result = self.discovery.discover_plugin_in_file(temp_file_path)\n            self.assertIsNotNone(result)\n            self.assertTrue(result.is_valid)\n            # The plugin name should match the class name since that's how our discovery works\n            self.assertEqual(result.plugin_name, "DiscoveredTestPlugin")\n        finally:\n            # Clean up\n            os.unlink(temp_file_path)\n\n    def test_validate_plugin_file(self):\n        """Test validating plugin files."""\n        # Valid plugin\n        with tempfile.NamedTemporaryFile(mode='w', suffix='.py', delete=False) as f:\n            f.write("""\nfrom plugin_system.core import BasePlugin, PluginMetadata, PluginType\n\nclass ValidTestPlugin(BasePlugin):\n    def __init__(self):\n        metadata = PluginMetadata(\n            name="valid_plugin",\n            version="1.0.0",\n            description="Valid test plugin",\n            author="Test",\n            plugin_type=PluginType.CUSTOM,\n            dependencies=[],\n            compatibility=["1.0.0"]\n        )\n        super().__init__(metadata)\n""")\n            valid_file_path = f.name\n\n        # Invalid plugin (syntax error)\n        with tempfile.NamedTemporaryFile(mode='w', suffix='.py', delete=False) as f:\n            f.write("invalid python syntax ((((")\n            invalid_file_path = f.name\n\n        try:\n            # Valid file should pass validation\n            is_valid, error = self.discovery.validate_plugin_file(valid_file_path)\n            self.assertTrue(is_valid, f"Validation failed: {error}")\n            \n            # Invalid file should fail validation\n            is_valid, error = self.discovery.validate_plugin_file(invalid_file_path)\n            self.assertFalse(is_valid)\n            self.assertIsNotNone(error)\n        finally:\n            # Clean up\n            os.unlink(valid_file_path)\n            os.unlink(invalid_file_path)\n\n\nclass TestConfiguration(unittest.TestCase):\n    """Tests for the plugin configuration system."""\n    \n    def setUp(self):\n        """Set up test fixtures."""\n        self.registry = PluginRegistry()\n        self.config_manager = PluginConfigurationManager(self.registry)\n\n    def test_plugin_configuration(self):\n        """Test plugin configuration management."""\n        plugin = TestPlugin()\n        self.registry.register_plugin(plugin)\n        \n        # Set configuration\n        config_data = {"param1": "value1", "param2": 42}\n        self.assertTrue(self.config_manager.set_plugin_config("test_plugin", config_data))\n        \n        # Get configuration\n        config = self.config_manager.get_plugin_config("test_plugin")\n        self.assertIsNotNone(config)\n        self.assertEqual(config.get("param1"), "value1")\n        self.assertEqual(config.get("param2"), 42)\n        \n        # Update configuration\n        update_data = {"param1": "updated_value"}\n        self.assertTrue(self.config_manager.update_plugin_config("test_plugin", update_data))\n        \n        config = self.config_manager.get_plugin_config("test_plugin")\n        self.assertEqual(config.get("param1"), "updated_value")\n        self.assertEqual(config.get("param2"), 42)\n\n    def test_config_validation(self):\n        """Test configuration validation."""\n        # Create a plugin with a schema\n        schema = {\n            "type": "object",\n            "properties": {\n                "required_param": {"type": "string", "default": "default_value"},\n                "optional_param": {"type": "number"}\n            },\n            "required": ["required_param"]\n        }\n        \n        metadata = PluginMetadata(\n            name="schema_plugin",\n            version="1.0.0",\n            description="Plugin with schema",\n            author="Test",\n            plugin_type=PluginType.CUSTOM,\n            dependencies=[],\n            compatibility=["1.0.0"],\n            config_schema=schema\n        )\n        plugin = BasePlugin(metadata)\n        \n        self.registry.register_plugin(plugin)\n        \n        # Valid config should pass\n        valid_config = {"required_param": "test_value"}\n        is_valid, error = self.config_manager.validate_config("schema_plugin", valid_config)\n        self.assertTrue(is_valid, f"Validation failed: {error}")\n        \n        # Invalid config should fail\n        invalid_config = {"optional_param": 123}  # Missing required_param\n        is_valid, error = self.config_manager.validate_config("schema_plugin", invalid_config)\n        self.assertFalse(is_valid)\n\n\nclass TestValidation(unittest.TestCase):\n    """Tests for the plugin validation system."""\n    \n    def setUp(self):\n        """Set up test fixtures."""\n        self.registry = PluginRegistry()\n        self.validator = PluginValidator(self.registry)\n\n    def test_plugin_validation(self):\n        """Test plugin validation."""\n        plugin = TestPlugin()\n        self.registry.register_plugin(plugin)\n        \n        # Valid plugin should pass validation\n        result = self.validator.validate_plugin_by_name("test_plugin")\n        self.assertTrue(result.is_valid)\n        self.assertEqual(len(result.error_messages), 0)\n        \n        # Check that warnings might exist\n        self.assertIsInstance(result.warning_messages, list)\n\n    def test_metadata_validation(self):\n        """Test metadata validation."""\n        # Valid metadata\n        valid_metadata = PluginMetadata(\n            name="valid_plugin",\n            version="1.0.0",\n            description="Valid plugin",\n            author="Test Author",\n            plugin_type=PluginType.CUSTOM,\n            dependencies=[],\n            compatibility=["1.0.0"]\n        )\n        result = self.validator._validate_metadata(valid_metadata)\n        self.assertTrue(result.is_valid)\n        \n        # Invalid metadata (missing name)\n        invalid_metadata = PluginMetadata(\n            name="",  # Empty name\n            version="1.0.0",\n            description="Invalid plugin",\n            author="Test Author",\n            plugin_type=PluginType.CUSTOM,\n            dependencies=[],\n            compatibility=["1.0.0"]\n        )\n        result = self.validator._validate_metadata(invalid_metadata)\n        self.assertFalse(result.is_valid)\n        self.assertGreater(len(result.error_messages), 0)\n\n\nclass TestCompatibility(unittest.TestCase):\n    """Tests for the compatibility layer."""\n    \n    def setUp(self):\n        """Set up test fixtures."""\n        self.registry = PluginRegistry()\n        self.compatibility_layer = CompatibilityLayer(self.registry)\n\n    def test_legacy_plugin_wrapper(self):\n        """Test wrapping legacy components as plugins."""\n        # Create a simple legacy component\n        class LegacyComponent:\n            def __init__(self):\n                self.initialized = False\n                self.active = False\n            \n            def initialize(self, config):\n                self.initialized = True\n                return True\n            \n            def activate(self):\n                self.active = True\n            \n            def deactivate(self):\n                self.active = False\n\n        legacy_component = LegacyComponent()\n        \n        # Wrap the legacy component\n        plugin_name = self.compatibility_layer.wrap_legacy_component(\n            legacy_component, \n            PluginType.CUSTOM, \n            "wrapped_legacy_component"\n        )\n        \n        self.assertIsNotNone(plugin_name)\n        \n        # Check that the wrapper is in the registry\n        plugin = self.registry.get_plugin(plugin_name)\n        self.assertIsInstance(plugin, LegacyPluginWrapper)\n        \n        # Get the original component back\n        retrieved_component = self.compatibility_layer.get_legacy_component(plugin_name)\n        self.assertIs(retrieved_component, legacy_component)\n\n\nclass TestIntegration(unittest.TestCase):\n    """Integration tests for the entire plugin system."""\n    \n    def setUp(self):\n        """Set up test fixtures."""\n        self.registry = get_plugin_registry()\n        self.lifecycle_manager = get_lifecycle_manager()\n        self.discovery = get_plugin_discovery()\n        self.loader = get_plugin_loader()\n        self.config_manager = get_config_manager()\n        self.validator = get_plugin_validator()\n        self.tester = get_plugin_tester()\n        self.compatibility_layer = get_compatibility_layer()\n        \n        # Clear all plugins for clean test\n        for plugin_name in list(self.registry._plugins.keys()):\n            self.lifecycle_manager.unload_plugin(plugin_name)\n\n    def test_full_plugin_lifecycle(self):\n        """Test the full lifecycle of a plugin."""\n        # Create a temporary plugin file\n        with tempfile.NamedTemporaryFile(mode='w', suffix='.py', delete=False) as f:\n            f.write("""\nfrom plugin_system.core import BasePlugin, PluginMetadata, PluginType\n\nclass FullLifecycleTestPlugin(BasePlugin):\n    def __init__(self):\n        metadata = PluginMetadata(\n            name="full_lifecycle_plugin",\n            version="1.0.0",\n            description="Full lifecycle test plugin",\n            author="Test",\n            plugin_type=PluginType.CUSTOM,\n            dependencies=[],\n            compatibility=["1.0.0"]\n        )\n        super().__init__(metadata)\n        \n    def initialize(self, config):\n        # Custom initialization logic\n        result = super().initialize(config)\n        return result\n""")\n            temp_file_path = f.name\n\n        try:\n            # Discover the plugin\n            discovery_result = self.discovery.discover_plugin_in_file(temp_file_path)\n            self.assertIsNotNone(discovery_result)\n            self.assertTrue(discovery_result.is_valid)\n            \n            # Validate the plugin file\n            is_valid, error = self.discovery.validate_plugin_file(temp_file_path)\n            self.assertTrue(is_valid, f"Plugin file validation failed: {error}")\n            \n            # Load the plugin\n            plugin_name = self.loader.load_plugin_from_file(temp_file_path)\n            self.assertIsNotNone(plugin_name)\n            self.assertEqual(plugin_name, "full_lifecycle_plugin")\n            \n            # Validate the loaded plugin\n            validation_result = self.validator.validate_plugin_by_name(plugin_name)\n            self.assertTrue(validation_result.is_valid)\n            \n            # Initialize the plugin\n            config = {"test_param": "test_value"}\n            self.assertTrue(self.lifecycle_manager.initialize_plugin(plugin_name, \n                                                                    PluginConfig(plugin_name, config)))\n            \n            # Activate the plugin\n            self.assertTrue(self.lifecycle_manager.activate_plugin(plugin_name))\n            \n            # Run tests on the plugin\n            test_results = self.tester.run_plugin_tests(plugin_name)\n            self.assertGreater(len(test_results), 0)\n            \n            # Check that some tests passed\n            passed_tests = [tr for tr in test_results if tr.passed]\n            self.assertGreater(len(passed_tests), 0)\n            \n            # Deactivate the plugin\n            self.assertTrue(self.lifecycle_manager.deactivate_plugin(plugin_name))\n            \n            # Unload the plugin\n            self.assertTrue(self.lifecycle_manager.unload_plugin(plugin_name))\n            \n            # Verify plugin is no longer in registry\n            self.assertIsNone(self.registry.get_plugin(plugin_name))\n            \n        finally:\n            # Clean up\n            os.unlink(temp_file_path)\n\n    def test_configuration_persistence(self):\n        """Test configuration persistence across plugin lifecycle."""\n        # Create and register a plugin\n        plugin = TestPlugin()\n        self.registry.register_plugin(plugin)\n        \n        # Set configuration\n        config_data = {"persistent_param": "persistent_value", "counter": 42}\n        self.assertTrue(self.config_manager.set_plugin_config("test_plugin", config_data))\n        \n        # Save configuration to temporary file\n        with tempfile.TemporaryDirectory() as temp_dir:\n            config_file = os.path.join(temp_dir, "test_config.json")\n            self.assertTrue(self.config_manager.save_config_to_file("test_plugin", config_file))\n            \n            # Load configuration from file to a new plugin (simulate restart)\n            # In a real scenario, we'd reload the plugin, but for testing\n            # we'll just verify the file was saved correctly\n            self.assertTrue(os.path.exists(config_file))\n            \n            with open(config_file, 'r') as f:\n                saved_config = json.load(f)\n            \n            self.assertEqual(saved_config["plugin_name"], "test_plugin")\n            self.assertEqual(saved_config["configuration"]["persistent_param"], "persistent_value")\n            self.assertEqual(saved_config["configuration"]["counter"], 42)\n\n\ndef run_all_tests():\n    """Run all tests in the plugin system."""\n    # Create a test suite\n    suite = unittest.TestSuite()\n    \n    # Add all test cases\n    suite.addTest(unittest.makeSuite(TestCore))\n    suite.addTest(unittest.makeSuite(TestRegistry))\n    suite.addTest(unittest.makeSuite(TestLifecycle))\n    suite.addTest(unittest.makeSuite(TestDiscovery))\n    suite.addTest(unittest.makeSuite(TestConfiguration))\n    suite.addTest(unittest.makeSuite(TestValidation))\n    suite.addTest(unittest.makeSuite(TestCompatibility))\n    suite.addTest(unittest.makeSuite(TestIntegration))\n    \n    # Run the tests\n    runner = unittest.TextTestRunner(verbosity=2)\n    result = runner.run(suite)\n    \n    return result\n\n\nif __name__ == '__main__':\n    # Run the tests\n    test_result = run_all_tests()\n    \n    # Print summary\n    print(f"\nTests run: {test_result.testsRun}")\n    print(f"Failures: {len(test_result.failures)}")\n    print(f"Errors: {len(test_result.errors)}")\n    print(f"Success: {test_result.wasSuccessful()}")\n    \n    if test_result.failures:\n        print("\nFailures:")\n        for test, traceback in test_result.failures:\n            print(f"  {test}: {traceback}")\n    \n    if test_result.errors:\n        print("\nErrors:")\n        for test, traceback in test_result.errors:\n            print(f"  {test}: {traceback}")