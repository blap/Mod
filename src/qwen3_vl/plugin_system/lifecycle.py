"""\nPlugin lifecycle management system for the optimization framework.\n\nThis module provides functionality for managing the complete lifecycle of plugins\nincluding loading, initialization, activation, deactivation, and unloading.\n"""\n\nimport os\nimport sys\nimport time\nimport threading\nfrom typing import Dict, List, Optional, Any, Callable\nfrom pathlib import Path\nimport logging\nimport weakref\n\nfrom plugin_system.core import IPlugin, PluginType, PluginState, PluginMetadata, PluginConfig, BasePlugin\n    IPlugin, PluginType, PluginState, PluginMetadata, PluginConfig,\n    BasePlugin\n)\nfrom plugin_system.registry import PluginRegistry, get_plugin_registry\n\n\nclass PluginLifecycleManager:\n    """\n    Manages the complete lifecycle of plugins including loading, initialization,\n    activation, deactivation, and unloading with proper dependency handling.\n    """\n    \n    def __init__(self, registry: Optional[PluginRegistry] = None):\n        """\n        Initialize the plugin lifecycle manager.\n        \n        Args:\n            registry: Optional plugin registry to use. If None, uses global registry.\n        """\n        self._registry = registry or get_plugin_registry()\n        self._logger = logging.getLogger(f"{self.__class__.__module__}.{self.__class__.__name__}")\n        self._lifecycle_lock = threading.RLock()\n        self._loading_plugins: Dict[str, threading.Event] = {}  # Track loading plugins\n        self._startup_sequence: List[str] = []  # Order of plugin activation during startup\n        self._shutdown_sequence: List[str] = []  # Order of plugin deactivation during shutdown\n\n    def load_plugin(self, plugin_path: str, config_data: Optional[Dict[str, Any]] = None) -> Optional[str]:\n        """\n        Load a plugin from a file path.\n        \n        Args:\n            plugin_path: Path to the plugin file\n            config_data: Optional configuration data for the plugin\n            \n        Returns:\n            Plugin name if successful, None otherwise\n        """\n        with self._lifecycle_lock:\n            try:\n                # Check if plugin is already being loaded\n                plugin_name = Path(plugin_path).stem\n                if plugin_name in self._loading_plugins:\n                    self._loading_plugins[plugin_name].wait()  # Wait for loading to complete\n                    return plugin_name if plugin_name in self._registry._plugins else None\n                \n                # Create loading event to track this loading operation\n                loading_event = threading.Event()\n                self._loading_plugins[plugin_name] = loading_event\n                \n                try:\n                    # Load plugin from file\n                    plugin = self._registry.load_plugin_from_file(plugin_path, config_data)\n                    if plugin:\n                        # Set initial configuration if provided\n                        if config_data:\n                            plugin_config = plugin.get_config()\n                            plugin_config.update(config_data)\n                        \n                        return plugin.get_metadata().name\n                    else:\n                        self._logger.error(f"Failed to load plugin from {plugin_path}")\n                        return None\n                finally:\n                    # Mark loading as complete\n                    loading_event.set()\n                    if plugin_name in self._loading_plugins:\n                        del self._loading_plugins[plugin_name]\n                        \n            except Exception as e:\n                self._logger.error(f"Error loading plugin from {plugin_path}: {e}")\n                # Ensure loading event is set even on error\n                loading_event = self._loading_plugins.get(plugin_name)\n                if loading_event:\n                    loading_event.set()\n                    if plugin_name in self._loading_plugins:\n                        del self._loading_plugins[plugin_name]\n                return None\n\n    def load_plugins_from_directory(self, directory_path: str, recursive: bool = True) -> List[str]:\n        """\n        Load all plugins from a directory.\n        \n        Args:\n            directory_path: Path to the directory containing plugin files\n            recursive: Whether to search subdirectories\n            \n        Returns:\n            List of successfully loaded plugin names\n        """\n        with self._lifecycle_lock:\n            return self._registry.load_plugins_from_directory(directory_path, recursive)\n\n    def initialize_plugin(self, plugin_name: str, config: Optional[PluginConfig] = None) -> bool:\n        """\n        Initialize a loaded plugin with configuration.\n        \n        Args:\n            plugin_name: Name of the plugin to initialize\n            config: Optional configuration to use. If None, uses existing config.\n            \n        Returns:\n            True if initialization was successful, False otherwise\n        """\n        with self._lifecycle_lock:\n            plugin = self._registry.get_plugin(plugin_name)\n            if not plugin:\n                self._logger.error(f"Plugin {plugin_name} not found in registry")\n                return False\n            \n            # Use provided config or get existing config\n            if config is None:\n                config = plugin.get_config()\n            \n            try:\n                return plugin.initialize(config)\n            except Exception as e:\n                self._logger.error(f"Error initializing plugin {plugin_name}: {e}")\n                return False\n\n    def initialize_all_plugins(self, config_overrides: Optional[Dict[str, Dict[str, Any]]] = None) -> Dict[str, bool]:\n        """\n        Initialize all loaded plugins.\n        \n        Args:\n            config_overrides: Optional dictionary mapping plugin names to config overrides\n            \n        Returns:\n            Dictionary mapping plugin names to initialization success status\n        """\n        with self._lifecycle_lock:\n            results = {}\n            config_overrides = config_overrides or {}\n            \n            for plugin in self._registry.get_loaded_plugins():\n                plugin_name = plugin.get_metadata().name\n                config = plugin.get_config()\n                \n                # Apply config overrides if provided\n                if plugin_name in config_overrides:\n                    config.update(config_overrides[plugin_name])\n                \n                results[plugin_name] = self.initialize_plugin(plugin_name, config)\n            \n            return results\n\n    def activate_plugin(self, plugin_name: str) -> bool:\n        """\n        Activate a plugin by name, handling dependencies automatically.\n        \n        Args:\n            plugin_name: Name of the plugin to activate\n            \n        Returns:\n            True if activation was successful, False otherwise\n        """\n        with self._lifecycle_lock:\n            # First check if dependencies are satisfied\n            unmet_deps = self._check_unmet_dependencies(plugin_name)\n            if unmet_deps:\n                self._logger.error(f"Cannot activate {plugin_name}, unmet dependencies: {unmet_deps}")\n                return False\n            \n            # Activate dependencies first\n            deps_activated = self._activate_dependencies(plugin_name)\n            if not deps_activated:\n                self._logger.error(f"Failed to activate dependencies for {plugin_name}")\n                return False\n            \n            # Activate the plugin\n            plugin = self._registry.get_plugin(plugin_name)\n            if plugin is None:\n                self._logger.error(f"Plugin {plugin_name} not found in registry")\n                return False\n\n            # Check if plugin has state attribute before checking its value\n            if hasattr(plugin, 'state') and plugin.state == PluginState.ACTIVE:\n                self._logger.info(f"Plugin {plugin_name} is already active")\n                return True\n\n            success = self._registry.activate_plugin(plugin_name)\n            if success:\n                if plugin_name not in self._startup_sequence:\n                    self._startup_sequence.append(plugin_name)\n                self._logger.info(f"Plugin {plugin_name} activated successfully")\n            else:\n                self._logger.error(f"Failed to activate plugin {plugin_name}")\n\n            return success\n\n    def activate_all_plugins(self) -> Dict[str, bool]:\n        """\n        Activate all plugins in dependency order.\n        \n        Returns:\n            Dictionary mapping plugin names to activation success status\n        """\n        with self._lifecycle_lock:\n            results = {}\n            \n            # Get dependency graph\n            dep_graph = self._registry.get_dependency_graph()\n            \n            # Sort plugins by dependency order using topological sort\n            sorted_plugins = self._topological_sort(list(dep_graph.keys()), dep_graph)\n            \n            for plugin_name in sorted_plugins:\n                results[plugin_name] = self.activate_plugin(plugin_name)\n            \n            return results\n\n    def deactivate_plugin(self, plugin_name: str) -> bool:\n        """\n        Deactivate a plugin by name, handling dependent plugins automatically.\n        \n        Args:\n            plugin_name: Name of the plugin to deactivate\n            \n        Returns:\n            True if deactivation was successful, False otherwise\n        """\n        with self._lifecycle_lock:\n            # First check if any other plugins depend on this one\n            dependents = self._registry.get_dependents_graph().get(plugin_name, [])\n\n            # Deactivate dependents first\n            for dependent_name in dependents:\n                dependent_plugin = self._registry.get_plugin(dependent_name)\n                if dependent_plugin and hasattr(dependent_plugin, 'state') and dependent_plugin.state == PluginState.ACTIVE:\n                    self._logger.info(f"Deactivating dependent plugin {dependent_name} before {plugin_name}")\n                    self._registry.deactivate_plugin(dependent_name)\n\n            # Deactivate the plugin\n            success = self._registry.deactivate_plugin(plugin_name)\n            if success:\n                # Remove from startup sequence if present\n                if plugin_name in self._startup_sequence:\n                    self._startup_sequence.remove(plugin_name)\n                # Add to shutdown sequence if not already there\n                if plugin_name not in self._shutdown_sequence:\n                    self._shutdown_sequence.insert(0, plugin_name)\n\n                self._logger.info(f"Plugin {plugin_name} deactivated successfully")\n            else:\n                self._logger.error(f"Failed to deactivate plugin {plugin_name}")\n\n            return success\n\n    def deactivate_all_plugins(self) -> Dict[str, bool]:\n        """\n        Deactivate all active plugins in reverse dependency order.\n        \n        Returns:\n            Dictionary mapping plugin names to deactivation success status\n        """\n        with self._lifecycle_lock:\n            results = {}\n            \n            # Get active plugins\n            active_plugins = self._registry.get_active_plugins()\n            \n            # Get dependency graph\n            dep_graph = self._registry.get_dependency_graph()\n            \n            # Sort in reverse dependency order\n            sorted_plugins = self._topological_sort(list(dep_graph.keys()), dep_graph)\n            sorted_plugins.reverse()\n            \n            for plugin_name in sorted_plugins:\n                plugin = self._registry.get_plugin(plugin_name)\n                if plugin and plugin.state == PluginState.ACTIVE:\n                    results[plugin_name] = self.deactivate_plugin(plugin_name)\n            \n            return results\n\n    def unload_plugin(self, plugin_name: str) -> bool:\n        """\n        Unload a plugin by name, deactivating it first if necessary.\n        \n        Args:\n            plugin_name: Name of the plugin to unload\n            \n        Returns:\n            True if unloading was successful, False otherwise\n        """\n        with self._lifecycle_lock:\n            plugin = self._registry.get_plugin(plugin_name)\n            if not plugin:\n                self._logger.error(f"Plugin {plugin_name} not found in registry")\n                return False\n            \n            # Deactivate if active\n            if plugin.state == PluginState.ACTIVE:\n                if not self.deactivate_plugin(plugin_name):\n                    self._logger.error(f"Failed to deactivate plugin {plugin_name} before unloading")\n                    return False\n            \n            # Remove from registry\n            success = self._registry.unregister_plugin(plugin_name)\n            if success:\n                self._logger.info(f"Plugin {plugin_name} unloaded successfully")\n            else:\n                self._logger.error(f"Failed to unload plugin {plugin_name}")\n            \n            return success\n\n    def unload_all_plugins(self) -> Dict[str, bool]:\n        """\n        Unload all plugins.\n        \n        Returns:\n            Dictionary mapping plugin names to unloading success status\n        """\n        with self._lifecycle_lock:\n            results = {}\n            \n            # Get all plugin names before iterating since we're modifying the registry\n            plugin_names = list(self._registry._plugins.keys())\n            \n            for plugin_name in plugin_names:\n                results[plugin_name] = self.unload_plugin(plugin_name)\n            \n            # Clear sequences\n            self._startup_sequence.clear()\n            self._shutdown_sequence.clear()\n            \n            return results\n\n    def _check_unmet_dependencies(self, plugin_name: str) -> List[str]:\n        """\n        Check if a plugin has unmet dependencies.\n        \n        Args:\n            plugin_name: Name of the plugin to check\n            \n        Returns:\n            List of unmet dependency names\n        """\n        dependencies = self._registry._dependencies.get(plugin_name, [])\n        unmet = []\n        \n        for dep_name in dependencies:\n            dep_plugin = self._registry.get_plugin(dep_name)\n            if not dep_plugin or dep_plugin.state != PluginState.ACTIVE:\n                unmet.append(dep_name)\n        \n        return unmet\n\n    def _activate_dependencies(self, plugin_name: str) -> bool:\n        """\n        Activate all dependencies of a plugin recursively.\n        \n        Args:\n            plugin_name: Name of the plugin whose dependencies to activate\n            \n        Returns:\n            True if all dependencies were activated successfully, False otherwise\n        """\n        dependencies = self._registry._dependencies.get(plugin_name, [])\n        \n        for dep_name in dependencies:\n            dep_plugin = self._registry.get_plugin(dep_name)\n            if not dep_plugin:\n                self._logger.error(f"Dependency {dep_name} not found for plugin {plugin_name}")\n                return False\n            \n            # Activate dependency if not already active\n            if dep_plugin.state != PluginState.ACTIVE:\n                if not self.activate_plugin(dep_name):\n                    self._logger.error(f"Failed to activate dependency {dep_name} for plugin {plugin_name}")\n                    return False\n        \n        return True\n\n    def _topological_sort(self, nodes: List[str], dependencies: Dict[str, List[str]]) -> List[str]:\n        """\n        Perform topological sort on plugins based on dependencies.\n        \n        Args:\n            nodes: List of plugin names\n            dependencies: Dictionary mapping plugin names to their dependencies\n            \n        Returns:\n            List of plugin names in dependency order\n        """\n        # Build adjacency list\n        graph = {node: [] for node in nodes}\n        for node, deps in dependencies.items():\n            for dep in deps:\n                if dep in graph:\n                    graph[dep].append(node)  # dep -> node (node depends on dep)\n        \n        # Perform topological sort\n        result = []\n        visited = set()\n        temp = set()\n        \n        def visit(node):\n            if node in temp:\n                raise ValueError(f"Circular dependency detected involving {node}")\n            if node in visited:\n                return\n            temp.add(node)\n            for neighbor in graph[node]:\n                visit(neighbor)\n            temp.remove(node)\n            visited.add(node)\n            result.append(node)\n        \n        for node in nodes:\n            if node not in visited:\n                visit(node)\n        \n        return result\n\n    def get_lifecycle_status(self) -> Dict[str, str]:\n        """\n        Get the lifecycle status of all plugins.\n        \n        Returns:\n            Dictionary mapping plugin names to their state as strings\n        """\n        with self._lifecycle_lock:\n            status = {}\n            for plugin_name, plugin in self._registry._plugins.items():\n                if isinstance(plugin, BasePlugin):\n                    status[plugin_name] = plugin.state.value\n                else:\n                    status[plugin_name] = "unknown"\n            return status\n\n    def get_startup_sequence(self) -> List[str]:\n        """\n        Get the sequence in which plugins were activated during startup.\n        \n        Returns:\n            List of plugin names in activation order\n        """\n        with self._lifecycle_lock:\n            return self._startup_sequence[:]\n\n    def get_shutdown_sequence(self) -> List[str]:\n        """\n        Get the sequence in which plugins were deactivated during shutdown.\n        \n        Returns:\n            List of plugin names in deactivation order\n        """\n        with self._lifecycle_lock:\n            return self._shutdown_sequence[:]\n\n    def reload_plugin(self, plugin_name: str, plugin_path: str, \n                      config_data: Optional[Dict[str, Any]] = None) -> bool:\n        """\n        Reload a plugin from file, replacing the existing instance.\n        \n        Args:\n            plugin_name: Name of the existing plugin to reload\n            plugin_path: Path to the new plugin file\n            config_data: Optional configuration data for the reloaded plugin\n            \n        Returns:\n            True if reload was successful, False otherwise\n        """\n        with self._lifecycle_lock:\n            # Deactivate the existing plugin if active\n            existing_plugin = self._registry.get_plugin(plugin_name)\n            was_active = False\n            if existing_plugin and existing_plugin.state == PluginState.ACTIVE:\n                was_active = True\n                self.deactivate_plugin(plugin_name)\n            \n            # Unload the existing plugin\n            if existing_plugin:\n                self.unload_plugin(plugin_name)\n            \n            # Load the new plugin\n            new_plugin_name = self.load_plugin(plugin_path, config_data)\n            if new_plugin_name != plugin_name:\n                self._logger.error(f"Reload failed: plugin name changed from {plugin_name} to {new_plugin_name}")\n                return False\n            \n            # Initialize the new plugin\n            new_plugin = self._registry.get_plugin(plugin_name)\n            if not new_plugin:\n                self._logger.error(f"Reload failed: could not get new plugin instance for {plugin_name}")\n                return False\n            \n            # Activate if the original was active\n            if was_active:\n                return self.activate_plugin(plugin_name)\n            \n            return True\n\n\n# Global lifecycle manager instance\nlifecycle_manager = PluginLifecycleManager()\n\n\ndef get_lifecycle_manager() -> PluginLifecycleManager:\n    """\n    Get the global plugin lifecycle manager instance.\n    \n    Returns:\n        PluginLifecycleManager instance\n    """\n    return lifecycle_manager