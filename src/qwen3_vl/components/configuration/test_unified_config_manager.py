"""Comprehensive tests for the unified configuration system."""\n\nimport unittest\nimport tempfile\nimport os\nfrom pathlib import Path\nimport torch\nimport json\nimport yaml\nfrom unittest.mock import patch\nimport numpy as np\n\nfrom components.configuration.unified_config_manager import BaseConfig, MemoryConfig, CPUConfig, GPUConfig, PowerManagementConfig, OptimizationConfig, UnifiedConfig, ConfigValidator, ConfigSourceManager, UnifiedConfigManager, get_default_config, create_unified_config_manager\n    BaseConfig, MemoryConfig, CPUConfig, GPUConfig, PowerManagementConfig,\n    OptimizationConfig, UnifiedConfig, ConfigValidator, ConfigSourceManager,\n    UnifiedConfigManager, get_default_config, create_unified_config_manager\n)\n\n\nclass TestBaseConfig(unittest.TestCase):\n    """Test the base configuration class."""\n    \n    def test_to_dict_from_dict(self):\n        """Test serialization and deserialization of base config."""\n        config = BaseConfig()\n        config_dict = config.to_dict()\n        restored_config = BaseConfig.from_dict(config_dict)\n        \n        # Since BaseConfig is empty, this should work\n        self.assertIsInstance(restored_config, BaseConfig)\n    \n    def test_save_load_file(self):\n        """Test saving and loading config from file."""\n        # Create a temporary config with some fields\n        class TestConfig(BaseConfig):\n            field1: int = 42\n            field2: str = "test"\n        \n        config = TestConfig(field1=100, field2="hello")\n        \n        with tempfile.NamedTemporaryFile(mode='w', suffix='.json', delete=False) as f:\n            temp_file = f.name\n        \n        try:\n            config.save_to_file(temp_file)\n            \n            loaded_config = TestConfig.from_file(temp_file)\n            self.assertEqual(loaded_config.field1, 100)\n            self.assertEqual(loaded_config.field2, "hello")\n        finally:\n            os.unlink(temp_file)\n\n\nclass TestMemoryConfig(unittest.TestCase):\n    """Test memory configuration."""\n    \n    def test_memory_config_initialization(self):\n        """Test memory configuration initialization."""\n        config = MemoryConfig()\n        \n        self.assertEqual(config.memory_pool_size, 2 * 1024 * 1024 * 1024)\n        self.assertEqual(config.memory_pool_dtype, "float16")\n        self.assertTrue(config.enable_memory_tiering)\n        self.assertEqual(config.compression_level, "medium")\n        self.assertTrue(config.enable_memory_swapping)\n        self.assertTrue(config.enable_memory_defragmentation)\n    \n    def test_memory_config_custom_values(self):\n        """Test memory configuration with custom values."""\n        config = MemoryConfig(\n            memory_pool_size=1024 * 1024 * 1024,  # 1GB\n            memory_pool_dtype="float32",\n            enable_memory_tiering=False,\n            gpu_memory_size=8 * 1024 * 1024 * 1024,  # 8GB\n            compression_level="high",\n            swap_threshold=0.9\n        )\n        \n        self.assertEqual(config.memory_pool_size, 1024 * 1024 * 1024)\n        self.assertEqual(config.memory_pool_dtype, "float32")\n        self.assertFalse(config.enable_memory_tiering)\n        self.assertEqual(config.gpu_memory_size, 8 * 1024 * 1024 * 1024)\n        self.assertEqual(config.compression_level, "high")\n        self.assertEqual(config.swap_threshold, 0.9)\n\n\nclass TestCPUConfig(unittest.TestCase):\n    """Test CPU configuration."""\n    \n    def test_cpu_config_initialization(self):\n        """Test CPU configuration initialization."""\n        config = CPUConfig()\n        \n        self.assertEqual(config.num_threads, 4)\n        self.assertEqual(config.num_workers, 4)\n        self.assertEqual(config.l1_cache_size, 32 * 1024)\n        self.assertEqual(config.l2_cache_size, 256 * 1024)\n        self.assertEqual(config.l3_cache_size, 6 * 1024 * 1024)\n        self.assertTrue(config.enable_cpu_optimizations)\n        self.assertTrue(config.use_hyperthreading)\n        self.assertTrue(config.enable_simd_optimizations)\n        self.assertEqual(config.simd_instruction_set, "avx2")\n    \n    def test_cpu_config_custom_values(self):\n        """Test CPU configuration with custom values."""\n        config = CPUConfig(\n            num_threads=8,\n            num_workers=6,\n            l3_cache_size=12 * 1024 * 1024,  # 12MB\n            simd_instruction_set="sse",\n            enable_cpu_optimizations=False,\n            memory_threshold=0.7\n        )\n        \n        self.assertEqual(config.num_threads, 8)\n        self.assertEqual(config.num_workers, 6)\n        self.assertEqual(config.l3_cache_size, 12 * 1024 * 1024)\n        self.assertEqual(config.simd_instruction_set, "sse")\n        self.assertFalse(config.enable_cpu_optimizations)\n        self.assertEqual(config.memory_threshold, 0.7)\n\n\nclass TestGPUConfig(unittest.TestCase):\n    """Test GPU configuration."""\n    \n    def test_gpu_config_initialization(self):\n        """Test GPU configuration initialization."""\n        config = GPUConfig()\n        \n        self.assertEqual(config.gpu_compute_capability, (6, 1))\n        self.assertEqual(config.max_threads_per_block, 1024)\n        self.assertEqual(config.shared_memory_per_block, 48 * 1024)\n        self.assertEqual(config.memory_bandwidth_gbps, 320.0)\n        self.assertTrue(config.enable_gpu_optimizations)\n        self.assertTrue(config.use_tensor_cores)\n        self.assertTrue(config.use_mixed_precision)\n        self.assertEqual(config.attention_implementation, "flash_attention_2")\n        self.assertEqual(config.kv_cache_strategy, "hybrid")\n    \n    def test_gpu_config_custom_values(self):\n        """Test GPU configuration with custom values."""\n        config = GPUConfig(\n            gpu_compute_capability=(7, 5),\n            max_threads_per_block=2048,\n            shared_memory_per_block=96 * 1024,\n            memory_bandwidth_gbps=900.0,\n            use_tensor_cores=False,\n            attention_implementation="optimized",\n            kv_cache_strategy="low_rank"\n        )\n        \n        self.assertEqual(config.gpu_compute_capability, (7, 5))\n        self.assertEqual(config.max_threads_per_block, 2048)\n        self.assertEqual(config.shared_memory_per_block, 96 * 1024)\n        self.assertEqual(config.memory_bandwidth_gbps, 900.0)\n        self.assertFalse(config.use_tensor_cores)\n        self.assertEqual(config.attention_implementation, "optimized")\n        self.assertEqual(config.kv_cache_strategy, "low_rank")\n\n\nclass TestPowerManagementConfig(unittest.TestCase):\n    """Test power management configuration."""\n    \n    def test_power_config_initialization(self):\n        """Test power management configuration initialization."""\n        config = PowerManagementConfig()\n        \n        self.assertTrue(config.enable_power_optimization)\n        self.assertEqual(config.power_constraint, 0.8)\n        self.assertEqual(config.thermal_constraint, 75.0)\n        self.assertEqual(config.performance_target, 0.9)\n        self.assertEqual(config.adaptation_frequency, 1.0)\n        self.assertTrue(config.enable_dynamic_power_scaling)\n    \n    def test_power_config_custom_values(self):\n        """Test power management configuration with custom values."""\n        config = PowerManagementConfig(\n            enable_power_optimization=False,\n            power_constraint=0.9,\n            thermal_constraint=80.0,\n            performance_target=0.95,\n            adaptation_frequency=2.0,\n            enable_dynamic_power_scaling=False\n        )\n        \n        self.assertFalse(config.enable_power_optimization)\n        self.assertEqual(config.power_constraint, 0.9)\n        self.assertEqual(config.thermal_constraint, 80.0)\n        self.assertEqual(config.performance_target, 0.95)\n        self.assertEqual(config.adaptation_frequency, 2.0)\n        self.assertFalse(config.enable_dynamic_power_scaling)\n\n\nclass TestOptimizationConfig(unittest.TestCase):\n    """Test optimization configuration."""\n    \n    def test_optimization_config_initialization(self):\n        """Test optimization configuration initialization."""\n        config = OptimizationConfig()\n        \n        self.assertTrue(config.use_memory_pooling)\n        self.assertTrue(config.use_hierarchical_memory_compression)\n        self.assertTrue(config.use_memory_efficient_attention)\n        self.assertTrue(config.use_sparsity)\n        self.assertEqual(config.sparsity_ratio, 0.5)\n        self.assertTrue(config.use_dynamic_sparse_attention)\n        self.assertTrue(config.use_adaptive_precision)\n        self.assertTrue(config.use_moe)\n        self.assertEqual(config.moe_num_experts, 4)\n        self.assertEqual(config.moe_top_k, 2)\n        self.assertTrue(config.use_flash_attention_2)\n        self.assertTrue(config.use_adaptive_depth)\n        self.assertTrue(config.use_gradient_checkpointing)\n        self.assertTrue(config.use_context_adaptive_positional_encoding)\n        self.assertTrue(config.use_conditional_feature_extraction)\n        self.assertTrue(config.use_cross_modal_compression)\n        self.assertTrue(config.use_cross_layer_memory_sharing)\n        self.assertTrue(config.use_hierarchical_vision)\n        self.assertTrue(config.use_learned_activation_routing)\n        self.assertTrue(config.use_adaptive_batch_processing)\n        self.assertTrue(config.use_adaptive_sequence_packing)\n        self.assertTrue(config.use_memory_efficient_grad_accumulation)\n        self.assertTrue(config.use_faster_rotary_embeddings)\n        self.assertFalse(config.use_distributed_pipeline_parallelism)\n        self.assertTrue(config.use_hardware_specific_kernels)\n        self.assertEqual(config.performance_improvement_threshold, 0.05)\n        self.assertEqual(config.accuracy_preservation_threshold, 0.95)\n    \n    def test_optimization_config_custom_values(self):\n        """Test optimization configuration with custom values."""\n        config = OptimizationConfig(\n            use_memory_pooling=False,\n            sparsity_ratio=0.3,\n            moe_num_experts=8,\n            moe_top_k=3,\n            performance_improvement_threshold=0.1,\n            accuracy_preservation_threshold=0.98\n        )\n        \n        self.assertFalse(config.use_memory_pooling)\n        self.assertEqual(config.sparsity_ratio, 0.3)\n        self.assertEqual(config.moe_num_experts, 8)\n        self.assertEqual(config.moe_top_k, 3)\n        self.assertEqual(config.performance_improvement_threshold, 0.1)\n        self.assertEqual(config.accuracy_preservation_threshold, 0.98)\n\n\nclass TestUnifiedConfig(unittest.TestCase):\n    """Test unified configuration."""\n    \n    def test_unified_config_initialization(self):\n        """Test unified configuration initialization."""\n        config = UnifiedConfig()\n        \n        self.assertEqual(config.num_hidden_layers, 32)\n        self.assertEqual(config.num_attention_heads, 32)\n        self.assertEqual(config.hidden_size, 4096)\n        self.assertEqual(config.intermediate_size, 11008)\n        self.assertEqual(config.vision_num_hidden_layers, 24)\n        self.assertEqual(config.vision_num_attention_heads, 16)\n        self.assertEqual(config.vision_hidden_size, 1152)\n        self.assertEqual(config.hardware_target, "intel_i5_10210u_nvidia_sm61_nvme")\n        self.assertEqual(config.target_hardware, "nvidia_sm61")\n        self.assertEqual(config.compute_units, 4)\n        self.assertEqual(config.memory_gb, 8.0)\n        self.assertEqual(config.torch_dtype, "float16")\n        self.assertEqual(config.optimization_level, "balanced")\n    \n    def test_unified_config_post_init_validation(self):\n        """Test post-initialization validation."""\n        # Test valid config\n        config = UnifiedConfig()\n        self.assertTrue(True)  # No exception means validation passed\n        \n        # Test invalid config - hidden_size not divisible by num_attention_heads\n        with self.assertRaises(ValueError):\n            UnifiedConfig(\n                hidden_size=512,\n                num_attention_heads=7  # Not a divisor of 512\n            )\n    \n    def test_unified_config_with_custom_subconfigs(self):\n        """Test unified config with custom sub-configurations."""\n        memory_config = MemoryConfig(\n            memory_pool_size=1024 * 1024 * 1024,  # 1GB\n            enable_memory_tiering=False\n        )\n        \n        cpu_config = CPUConfig(\n            num_threads=8,\n            enable_cpu_optimizations=False\n        )\n        \n        gpu_config = GPUConfig(\n            gpu_compute_capability=(7, 0),\n            use_tensor_cores=False\n        )\n        \n        power_config = PowerManagementConfig(\n            enable_power_optimization=False,\n            thermal_constraint=80.0\n        )\n        \n        optimization_config = OptimizationConfig(\n            use_sparsity=False,\n            use_moe=False\n        )\n        \n        config = UnifiedConfig(\n            memory_config=memory_config,\n            cpu_config=cpu_config,\n            gpu_config=gpu_config,\n            power_config=power_config,\n            optimization_config=optimization_config\n        )\n        \n        self.assertEqual(config.memory_config.memory_pool_size, 1024 * 1024 * 1024)\n        self.assertFalse(config.memory_config.enable_memory_tiering)\n        self.assertEqual(config.cpu_config.num_threads, 8)\n        self.assertFalse(config.cpu_config.enable_cpu_optimizations)\n        self.assertEqual(config.gpu_config.gpu_compute_capability, (7, 0))\n        self.assertFalse(config.gpu_config.use_tensor_cores)\n        self.assertFalse(config.power_config.enable_power_optimization)\n        self.assertEqual(config.power_config.thermal_constraint, 80.0)\n        self.assertFalse(config.optimization_config.use_sparsity)\n        self.assertFalse(config.optimization_config.use_moe)\n\n\nclass TestConfigValidator(unittest.TestCase):\n    """Test configuration validator."""\n    \n    def test_config_validation(self):\n        """Test configuration validation."""\n        validator = ConfigValidator()\n        \n        # Valid config should pass\n        config = UnifiedConfig()\n        errors = validator.validate_config(config)\n        self.assertEqual(len(errors), 0)\n        \n        # Invalid config should fail\n        invalid_config = UnifiedConfig(\n            num_hidden_layers=-1,\n            num_attention_heads=0,\n            hidden_size=0,\n            memory_config=MemoryConfig(\n                memory_pool_size=0,\n                compression_threshold=1.5  # > 1\n            ),\n            cpu_config=CPUConfig(\n                num_threads=0\n            ),\n            gpu_config=GPUConfig(\n                max_threads_per_block=0\n            ),\n            optimization_config=OptimizationConfig(\n                sparsity_ratio=1.5,  # > 1\n                moe_num_experts=1   # < 2\n            )\n        )\n        \n        errors = validator.validate_config(invalid_config)\n        self.assertGreater(len(errors), 0)\n        self.assertTrue(any("num_hidden_layers" in error for error in errors))\n        self.assertTrue(any("num_attention_heads" in error for error in errors))\n        self.assertTrue(any("hidden_size" in error for error in errors))\n        self.assertTrue(any("memory_pool_size" in error for error in errors))\n        self.assertTrue(any("compression_threshold" in error for error in errors))\n        self.assertTrue(any("num_threads" in error for error in errors))\n        self.assertTrue(any("max_threads_per_block" in error for error in errors))\n        self.assertTrue(any("sparsity_ratio" in error for error in errors))\n        self.assertTrue(any("moe_num_experts" in error for error in errors))\n    \n    def test_optimization_compatibility_validation(self):\n        """Test optimization compatibility validation."""\n        validator = ConfigValidator()\n        \n        # Valid optimization config should pass\n        opt_config = OptimizationConfig()\n        errors = validator.validate_optimization_compatibility(opt_config)\n        self.assertEqual(len(errors), 0)\n\n\nclass TestConfigSourceManager(unittest.TestCase):\n    """Test configuration source manager."""\n    \n    def test_add_source(self):\n        """Test adding sources."""\n        source_manager = ConfigSourceManager()\n        \n        # Add dict source\n        source_manager.add_source("dict_source", {"num_hidden_layers": 16})\n        \n        # Add config object source\n        config_obj = UnifiedConfig(num_attention_heads=16)\n        source_manager.add_source("obj_source", config_obj)\n        \n        # Add file path source (we'll test loading later)\n        source_manager.add_source("file_source", "dummy_path.json")\n        \n        self.assertEqual(len(source_manager.sources), 3)\n        self.assertIn("dict_source", source_manager.sources)\n        self.assertIn("obj_source", source_manager.sources)\n        self.assertIn("file_source", source_manager.sources)\n    \n    def test_merge_configs(self):\n        """Test merging configurations."""\n        source_manager = ConfigSourceManager()\n        \n        base_config = UnifiedConfig(num_hidden_layers=32, num_attention_heads=32)\n        overrides = {"num_hidden_layers": 16, "num_attention_heads": 16}\n        \n        merged_config = source_manager.merge_configs(base_config, overrides)\n        \n        self.assertEqual(merged_config.num_hidden_layers, 16)\n        self.assertEqual(merged_config.num_attention_heads, 16)\n        # Other values should remain unchanged\n        self.assertEqual(merged_config.hidden_size, base_config.hidden_size)\n    \n    def test_deep_merge(self):\n        """Test deep merging of configurations."""\n        source_manager = ConfigSourceManager()\n        \n        base = {\n            "nested": {\n                "a": 1,\n                "b": 2\n            },\n            "simple": 3\n        }\n        \n        overrides = {\n            "nested": {\n                "b": 20,  # Change nested value\n                "c": 30   # Add new nested value\n            },\n            "simple": 30  # Change simple value\n        }\n        \n        result = source_manager._deep_merge(base, overrides)\n        \n        self.assertEqual(result["nested"]["a"], 1)  # Unchanged\n        self.assertEqual(result["nested"]["b"], 20) # Overridden\n        self.assertEqual(result["nested"]["c"], 30) # Added\n        self.assertEqual(result["simple"], 30)     # Overridden\n    \n    def test_resolve_config(self):\n        """Test resolving configuration from multiple sources."""\n        source_manager = ConfigSourceManager()\n        \n        # Add multiple sources\n        source_manager.add_source("source1", {"num_hidden_layers": 16})\n        source_manager.add_source("source2", {"num_attention_heads": 16})\n        source_manager.add_source("source3", {"hidden_size": 2048})\n        \n        # Resolve config with specific precedence\n        resolved = source_manager.resolve_config(["source1", "source2", "source3"])\n        \n        # Values should come from the sources\n        self.assertEqual(resolved.num_hidden_layers, 16)\n        self.assertEqual(resolved.num_attention_heads, 16)\n        self.assertEqual(resolved.hidden_size, 2048)\n    \n    def test_load_from_file(self):\n        """Test loading configuration from file."""\n        source_manager = ConfigSourceManager()\n        \n        # Create temporary JSON file\n        with tempfile.NamedTemporaryFile(mode='w', suffix='.json', delete=False) as f:\n            json.dump({"num_hidden_layers": 8, "num_attention_heads": 8}, f)\n            temp_json = f.name\n        \n        # Create temporary YAML file\n        with tempfile.NamedTemporaryFile(mode='w', suffix='.yaml', delete=False) as f:\n            yaml.dump({"num_hidden_layers": 12, "num_attention_heads": 12}, f)\n            temp_yaml = f.name\n        \n        try:\n            # Load from JSON\n            json_config = source_manager.load_from_file(temp_json)\n            self.assertEqual(json_config["num_hidden_layers"], 8)\n            self.assertEqual(json_config["num_attention_heads"], 8)\n            \n            # Load from YAML\n            yaml_config = source_manager.load_from_file(temp_yaml)\n            self.assertEqual(yaml_config["num_hidden_layers"], 12)\n            self.assertEqual(yaml_config["num_attention_heads"], 12)\n        finally:\n            os.unlink(temp_json)\n            os.unlink(temp_yaml)\n    \n    @patch.dict(os.environ, {\n        "QWEN3_NUM_HIDDEN_LAYERS": "10",\n        "QWEN3_NUM_ATTENTION_HEADS": "10",\n        "QWEN3_HIDDEN_SIZE": "1024",\n        "QWEN3_USE_SPARSITY": "true",\n        "QWEN3_PERFORMANCE_THRESHOLD": "0.1"\n    })\n    def test_load_from_env(self):\n        """Test loading configuration from environment variables."""\n        source_manager = ConfigSourceManager()\n        env_config = source_manager.load_from_env("QWEN3_")\n        \n        self.assertEqual(env_config["num_hidden_layers"], 10)\n        self.assertEqual(env_config["num_attention_heads"], 10)\n        self.assertEqual(env_config["hidden_size"], 1024)\n        self.assertTrue(env_config["use_sparsity"])\n        self.assertEqual(env_config["performance_threshold"], 0.1)\n\n\nclass TestUnifiedConfigManager(unittest.TestCase):\n    """Test unified configuration manager."""\n    \n    def test_initialization(self):\n        """Test configuration manager initialization."""\n        manager = UnifiedConfigManager()\n        \n        self.assertIsInstance(manager.validator, ConfigValidator)\n        self.assertIsInstance(manager.source_manager, ConfigSourceManager)\n        self.assertIsInstance(manager.base_config, UnifiedConfig)\n    \n    def test_get_config_by_level(self):\n        """Test getting configurations by optimization level."""\n        manager = UnifiedConfigManager()\n        \n        # Test different optimization levels\n        minimal_config = manager.get_config("minimal")\n        balanced_config = manager.get_config("balanced")\n        aggressive_config = manager.get_config("aggressive")\n        \n        # Each should have different optimization settings\n        self.assertFalse(minimal_config.optimization_config.use_memory_pooling)\n        self.assertTrue(balanced_config.optimization_config.use_memory_pooling)\n        self.assertTrue(aggressive_config.optimization_config.use_memory_pooling)\n        \n        # But all should maintain capacity\n        self.assertEqual(minimal_config.num_hidden_layers, 32)\n        self.assertEqual(balanced_config.num_hidden_layers, 32)\n        self.assertEqual(aggressive_config.num_hidden_layers, 32)\n    \n    def test_validate_config(self):\n        """Test configuration validation."""\n        manager = UnifiedConfigManager()\n        \n        # Valid config should pass\n        config = UnifiedConfig()\n        is_valid = manager.validate_config(config)\n        self.assertTrue(is_valid)\n        \n        # Invalid config should fail\n        invalid_config = UnifiedConfig(num_hidden_layers=-1)\n        is_valid = manager.validate_config(invalid_config)\n        self.assertFalse(is_valid)\n    \n    def test_update_config(self):\n        """Test updating configuration."""\n        manager = UnifiedConfigManager()\n        base_config = UnifiedConfig(num_hidden_layers=32, num_attention_heads=32)\n        \n        updates = {\n            "num_hidden_layers": 16,\n            "num_attention_heads": 16,\n            "optimization_config": {\n                "use_sparsity": False,\n                "sparsity_ratio": 0.0\n            }\n        }\n        \n        updated_config = manager.update_config(base_config, updates)\n        \n        self.assertEqual(updated_config.num_hidden_layers, 16)\n        self.assertEqual(updated_config.num_attention_heads, 16)\n        self.assertFalse(updated_config.optimization_config.use_sparsity)\n        self.assertEqual(updated_config.optimization_config.sparsity_ratio, 0.0)\n    \n    def test_get_hardware_optimized_config(self):\n        """Test getting hardware-optimized configuration."""\n        manager = UnifiedConfigManager()\n        \n        hardware_specs = {\n            "gpu_memory": 8 * 1024 * 1024 * 1024,  # 8GB\n            "cpu_cores": 8,\n            "memory_gb": 16,\n            "storage_type": "nvme"\n        }\n        \n        hw_config = manager.get_hardware_optimized_config(hardware_specs)\n        \n        # Verify the config has been adjusted for the hardware\n        self.assertLessEqual(hw_config.memory_config.memory_pool_size, 16 * 1024 * 1024 * 1024 * 0.5)  # 50% of 16GB\n        self.assertEqual(hw_config.cpu_config.num_threads, 8)\n        self.assertTrue(hw_config.memory_config.enable_memory_swapping)\n    \n    def test_load_config_from_file(self):\n        """Test loading configuration from file."""\n        manager = UnifiedConfigManager()\n        \n        # Create a temporary config file\n        config_data = {\n            "num_hidden_layers": 16,\n            "num_attention_heads": 16,\n            "optimization_config": {\n                "use_sparsity": True,\n                "sparsity_ratio": 0.4\n            }\n        }\n        \n        with tempfile.NamedTemporaryFile(mode='w', suffix='.json', delete=False) as f:\n            json.dump(config_data, f)\n            temp_file = f.name\n        \n        try:\n            success = manager.load_config_from_file(temp_file, "test_file_config")\n            self.assertTrue(success)\n            \n            # Verify the loaded config\n            loaded_config = manager.source_manager.sources.get("test_file_config")\n            if loaded_config:\n                self.assertEqual(loaded_config.num_hidden_layers, 16)\n                self.assertEqual(loaded_config.num_attention_heads, 16)\n                self.assertTrue(loaded_config.optimization_config.use_sparsity)\n                self.assertEqual(loaded_config.optimization_config.sparsity_ratio, 0.4)\n        finally:\n            os.unlink(temp_file)\n    \n    def test_load_config_from_env(self):\n        """Test loading configuration from environment."""\n        manager = UnifiedConfigManager()\n        \n        with patch.dict(os.environ, {\n            "QWEN3_NUM_HIDDEN_LAYERS": "20",\n            "QWEN3_NUM_ATTENTION_HEADS": "20",\n            "QWEN3_USE_MOE": "true",\n            "QWEN3_MOE_NUM_EXPERTS": "6"\n        }):\n            success = manager.load_config_from_env("env_config", "QWEN3_")\n            self.assertTrue(success)\n            \n            # Verify the loaded config\n            loaded_config = manager.source_manager.sources.get("env_config")\n            if loaded_config:\n                self.assertEqual(loaded_config.num_hidden_layers, 20)\n                self.assertEqual(loaded_config.num_attention_heads, 20)\n                self.assertTrue(loaded_config.optimization_config.use_moe)\n                self.assertEqual(loaded_config.optimization_config.moe_num_experts, 6)\n\n\nclass TestBackwardCompatibility(unittest.TestCase):\n    """Test backward compatibility functions."""\n    \n    def test_get_legacy_config(self):\n        """Test getting legacy configuration."""\n        legacy_dict = get_legacy_config()\n        \n        self.assertIsInstance(legacy_dict, dict)\n        self.assertIn("num_hidden_layers", legacy_dict)\n        self.assertIn("num_attention_heads", legacy_dict)\n        self.assertEqual(legacy_dict["num_hidden_layers"], 32)\n        self.assertEqual(legacy_dict["num_attention_heads"], 32)\n    \n    def test_update_legacy_config(self):\n        """Test updating legacy configuration."""\n        legacy_dict = get_legacy_config()\n        updates = {\n            "num_hidden_layers": 16,\n            "num_attention_heads": 16,\n            "use_sparsity": False\n        }\n        \n        updated_dict = update_legacy_config(legacy_dict, updates)\n        \n        self.assertEqual(updated_dict["num_hidden_layers"], 16)\n        self.assertEqual(updated_dict["num_attention_heads"], 16)\n        self.assertFalse(updated_dict["use_sparsity"])\n\n\nclass TestIntegration(unittest.TestCase):\n    """Integration tests for the configuration system."""\n    \n    def test_full_config_workflow(self):\n        """Test the full configuration workflow."""\n        # Create manager\n        manager = create_unified_config_manager()\n        \n        # Get balanced config\n        config = manager.get_config("balanced")\n        \n        # Validate config\n        is_valid = manager.validate_config(config)\n        self.assertTrue(is_valid)\n        \n        # Save to file\n        with tempfile.NamedTemporaryFile(mode='w', suffix='.json', delete=False) as f:\n            temp_file = f.name\n        \n        try:\n            config.save_to_file(temp_file)\n            \n            # Load from file\n            loaded_config = UnifiedConfig.from_file(temp_file)\n            \n            # Validate loaded config\n            is_loaded_valid = manager.validate_config(loaded_config)\n            self.assertTrue(is_loaded_valid)\n            \n            # Update config\n            updates = {"num_hidden_layers": 24, "num_attention_heads": 24}\n            updated_config = manager.update_config(loaded_config, updates)\n            \n            # Validate updated config\n            is_updated_valid = manager.validate_config(updated_config)\n            self.assertTrue(is_updated_valid)\n            \n            # Check that values were updated correctly\n            self.assertEqual(updated_config.num_hidden_layers, 24)\n            self.assertEqual(updated_config.num_attention_heads, 24)\n        finally:\n            os.unlink(temp_file)\n    \n    def test_hardware_optimized_workflow(self):\n        """Test hardware-optimized configuration workflow."""\n        manager = create_unified_config_manager()\n        \n        # Hardware specs for Intel i5-10210U + NVIDIA SM61\n        hardware_specs = {\n            "gpu_memory": 6 * 1024 * 1024 * 1024,  # 6GB\n            "cpu_cores": 4,\n            "memory_gb": 8,\n            "storage_type": "nvme"\n        }\n        \n        # Get hardware-optimized config\n        hw_config = manager.get_hardware_optimized_config(hardware_specs)\n        \n        # Validate config\n        is_valid = manager.validate_config(hw_config)\n        self.assertTrue(is_valid)\n        \n        # Check that config values are appropriate for the hardware\n        self.assertLessEqual(hw_config.memory_config.memory_pool_size, 8 * 1024 * 1024 * 1024 * 0.5)  # 50% of 8GB\n        self.assertEqual(hw_config.cpu_config.num_threads, 4)\n        self.assertTrue(hw_config.memory_config.enable_memory_swapping)\n    \n    def test_multiple_source_integration(self):\n        """Test integration with multiple configuration sources."""\n        manager = create_unified_config_manager()\n        source_manager = manager.source_manager\n        \n        # Add multiple sources\n        source_manager.add_source("base", {"num_hidden_layers": 32, "num_attention_heads": 32})\n        source_manager.add_source("optimizations", {\n            "optimization_config": {\n                "use_sparsity": True,\n                "sparsity_ratio": 0.3\n            }\n        })\n        \n        # Create a config from sources\n        base_config = UnifiedConfig()\n        optimized_config = source_manager.merge_configs(base_config, source_manager.sources["optimizations"])\n        \n        self.assertTrue(optimized_config.optimization_config.use_sparsity)\n        self.assertEqual(optimized_config.optimization_config.sparsity_ratio, 0.3)\n        self.assertEqual(optimized_config.num_hidden_layers, 32)  # Preserved from base\n        self.assertEqual(optimized_config.num_attention_heads, 32)  # Preserved from base\n\n\nif __name__ == "__main__":\n    # Run the tests\n    unittest.main(verbosity=2)