"""\nPower Management System with Hardware Detection and Fallback Mechanisms\nThis module implements a robust power management system that works across different hardware configurations\nby detecting available components and providing appropriate fallbacks when components are missing.\n"""\n\nimport time\nimport threading\nimport psutil\nimport subprocess\nimport logging\nfrom typing import Dict, List, Callable, Optional, Any, Tuple\nfrom dataclasses import dataclass\nfrom enum import Enum\nimport torch\nfrom components.system.hardware_detection_fallbacks import SafeHardwareInterface, HardwareCapabilities\n\n\n@dataclass\nclass PowerConstraint:\n    """Represents power and thermal constraints for the system"""\n    max_cpu_power_watts: float = 25.0  # TDP of i5-10210U\n    max_gpu_power_watts: float = 75.0  # Typical for mobile GPUs\n    max_cpu_temp_celsius: float = 90.0\n    max_gpu_temp_celsius: float = 85.0\n    max_cpu_usage_percent: float = 90.0\n    max_gpu_usage_percent: float = 85.0\n\n\n@dataclass\nclass PowerState:\n    """Current power and thermal state of the system"""\n    cpu_usage_percent: float = 0.0\n    gpu_usage_percent: float = 0.0\n    cpu_temp_celsius: float = 0.0\n    gpu_temp_celsius: float = 0.0\n    cpu_power_watts: float = 0.0\n    gpu_power_watts: float = 0.0\n    timestamp: float = 0.0\n\n\nclass PowerMode(Enum):\n    """Different power modes for the system"""\n    PERFORMANCE = "performance"\n    BALANCED = "balanced"\n    POWER_SAVE = "power_save"\n    THERMAL_MANAGEMENT = "thermal_management"\n\n\nclass RobustPowerAwareScheduler:\n    """\n    Power-aware task scheduler with comprehensive error handling and fallback mechanisms.\n    Works on systems with or without GPU, temperature sensors, or power management interfaces.\n    """\n\n    def __init__(self, constraints: PowerConstraint, hardware_interface: SafeHardwareInterface):\n        self.constraints = constraints\n        self.hardware_interface = hardware_interface\n        self.tasks: List[Dict] = []\n        self.running_tasks: List[Dict] = []\n        self.power_state = PowerState()\n        self.power_mode = PowerMode.BALANCED\n        self.monitoring_thread = None\n        self.is_monitoring = False\n        self.task_queue_lock = threading.Lock()\n        self.callbacks: List[Callable] = []\n\n        # Initialize logging\n        self.logger = logging.getLogger(__name__)\n\n    def get_system_power_state(self) -> PowerState:\n        """Get current system power and thermal state with fallbacks"""\n        state = PowerState()\n\n        try:\n            # Get CPU usage\n            state.cpu_usage_percent = psutil.cpu_percent(interval=0.1)\n        except Exception as e:\n            self.logger.warning(f"CPU usage detection failed: {e}")\n            state.cpu_usage_percent = 0.0\n\n        # Get CPU temperature with fallback\n        try:\n            state.cpu_temp_celsius = self.hardware_interface.get_temperature('cpu')\n        except Exception as e:\n            self.logger.warning(f"CPU temperature detection failed: {e}")\n            state.cpu_temp_celsius = 40.0  # Default fallback\n\n        # Get GPU info with fallback\n        try:\n            if self.hardware_interface.hardware_detector.capabilities.gpu_available:\n                gpu_info = self.hardware_interface.get_gpu_info()\n                state.gpu_usage_percent = gpu_info.get('utilization', 0.0)\n                state.gpu_temp_celsius = self.hardware_interface.get_temperature('gpu')\n\n                # Estimate GPU power based on utilization\n                state.gpu_power_watts = self.constraints.max_gpu_power_watts * (state.gpu_usage_percent / 100.0)\n            else:\n                # Use fallback values for systems without GPU\n                state.gpu_usage_percent = 0.0\n                state.gpu_temp_celsius = 0.0\n                state.gpu_power_watts = 0.0\n        except Exception as e:\n            self.logger.warning(f"GPU info detection failed: {e}")\n            # Use fallback values\n            state.gpu_usage_percent = 0.0\n            state.gpu_temp_celsius = 0.0\n            state.gpu_power_watts = 0.0\n\n        # Estimate CPU power based on usage\n        try:\n            state.cpu_power_watts = self.hardware_interface.get_power_usage()\n        except Exception as e:\n            self.logger.warning(f"CPU power detection failed: {e}")\n            # Fallback: estimate power based on CPU usage\n            state.cpu_power_watts = self.constraints.max_cpu_power_watts * (state.cpu_usage_percent / 100.0)\n\n        state.timestamp = time.time()\n        self.power_state = state\n\n        return state\n\n    def add_task(self, task_func: Callable, priority: int = 1, power_requirements: float = 1.0):\n        """Add a task to the scheduler with power requirements and error handling"""\n        try:\n            task = {\n                'id': len(self.tasks),\n                'function': task_func,\n                'priority': priority,\n                'power_requirements': power_requirements,  # Relative power requirement (0.0-1.0)\n                'created_at': time.time()\n            }\n\n            with self.task_queue_lock:\n                self.tasks.append(task)\n                # Sort by priority (higher priority first)\n                self.tasks.sort(key=lambda x: x['priority'], reverse=True)\n\n            self.logger.info(f"Added task {task['id']} with priority {priority}")\n        except Exception as e:\n            self.logger.error(f"Failed to add task: {e}")\n\n    def should_execute_task(self, task: Dict) -> bool:\n        """Determine if a task should be executed based on current power state and constraints"""\n        try:\n            current_state = self.power_state\n\n            # Check if we're in thermal management mode\n            if self.power_mode == PowerMode.THERMAL_MANAGEMENT:\n                return task['priority'] > 5  # Only execute high priority tasks\n\n            # Check CPU constraints\n            if current_state.cpu_usage_percent > self.constraints.max_cpu_usage_percent:\n                return False\n\n            if current_state.cpu_temp_celsius > self.constraints.max_cpu_temp_celsius * 0.9:\n                return False  # Throttle if approaching thermal limit\n\n            # Check GPU constraints if task might use GPU\n            if (self.hardware_interface.hardware_detector.capabilities.gpu_available and\n                current_state.gpu_temp_celsius > self.constraints.max_gpu_temp_celsius * 0.9):\n                return False  # Throttle if GPU is approaching thermal limit\n\n            # For power save mode, be more restrictive\n            if self.power_mode == PowerMode.POWER_SAVE:\n                return task['priority'] > 3 and current_state.cpu_usage_percent < 70.0\n\n            # For performance mode, be less restrictive\n            if self.power_mode == PowerMode.PERFORMANCE:\n                return True\n\n            # Balanced mode - normal constraints\n            return True\n\n        except Exception as e:\n            self.logger.error(f"Error checking task execution eligibility: {e}")\n            # Default to allowing execution if we can't determine constraints\n            return True\n\n    def execute_tasks(self):\n        """Execute tasks based on power and thermal constraints with error handling"""\n        try:\n            with self.task_queue_lock:\n                tasks_to_execute = []\n                for task in self.tasks[:]:  # Create a copy to avoid modification during iteration\n                    if self.should_execute_task(task):\n                        tasks_to_execute.append(task)\n                        # Remove from main task list\n                        self.tasks.remove(task)\n                        self.running_tasks.append(task)\n\n            # Execute tasks in a thread pool\n            for task in tasks_to_execute:\n                self._execute_task_async(task)\n        except Exception as e:\n            self.logger.error(f"Error executing tasks: {e}")\n\n    def _execute_task_async(self, task: Dict):\n        """Execute a task asynchronously with error handling"""\n        def wrapper():\n            try:\n                result = task['function']()\n                self.logger.info(f"Completed task {task['id']}")\n                return result\n            except Exception as e:\n                self.logger.error(f"Error executing task {task['id']}: {str(e)}")\n            finally:\n                with self.task_queue_lock:\n                    if task in self.running_tasks:\n                        self.running_tasks.remove(task)\n\n        try:\n            thread = threading.Thread(target=wrapper)\n            thread.daemon = True\n            thread.start()\n        except Exception as e:\n            self.logger.error(f"Failed to start task execution thread: {e}")\n\n    def start_monitoring(self, interval: float = 1.0):\n        """Start monitoring system power and thermal state with error handling"""\n        if self.is_monitoring:\n            return\n\n        self.is_monitoring = True\n        try:\n            self.monitoring_thread = threading.Thread(target=self._monitor_loop, args=(interval,))\n            self.monitoring_thread.daemon = True\n            self.monitoring_thread.start()\n            self.logger.info("Started power and thermal monitoring")\n        except Exception as e:\n            self.logger.error(f"Failed to start monitoring: {e}")\n            self.is_monitoring = False\n\n    def stop_monitoring(self):\n        """Stop monitoring system power and thermal state"""\n        self.is_monitoring = False\n        if self.monitoring_thread:\n            try:\n                self.monitoring_thread.join(timeout=2.0)\n            except Exception as e:\n                self.logger.error(f"Error stopping monitoring thread: {e}")\n        self.logger.info("Stopped power and thermal monitoring")\n\n    def _monitor_loop(self, interval: float):\n        """Main monitoring loop with error handling"""\n        while self.is_monitoring:\n            try:\n                self.get_system_power_state()\n                self._adjust_power_mode()\n                self._execute_tasks()\n\n                # Allow other threads to run\n                time.sleep(interval)\n            except Exception as e:\n                self.logger.error(f"Error in monitoring loop: {e}")\n                # Continue monitoring even if there's an error\n                time.sleep(interval)\n\n    def _adjust_power_mode(self):\n        """Adjust power mode based on current thermal and power state with fallbacks"""\n        try:\n            state = self.power_state\n            caps = self.hardware_interface.hardware_detector.capabilities\n\n            # Check for thermal emergency (only if temperature sensors are available)\n            if caps.temperature_sensors_available:\n                if (state.cpu_temp_celsius > self.constraints.max_cpu_temp_celsius or\n                    state.gpu_temp_celsius > self.constraints.max_gpu_temp_celsius):\n                    self.power_mode = PowerMode.THERMAL_MANAGEMENT\n                    self.logger.warning("Thermal emergency detected! Switching to thermal management mode")\n                    return\n\n                # Check for high temperature (approaching limits)\n                if (state.cpu_temp_celsius > self.constraints.max_cpu_temp_celsius * 0.8 or\n                    state.gpu_temp_celsius > self.constraints.max_gpu_temp_celsius * 0.8):\n                    self.power_mode = PowerMode.POWER_SAVE\n                    self.logger.info("High temperature detected! Switching to power save mode")\n                    return\n\n            # Check for high usage (only if usage metrics are reliable)\n            if (state.cpu_usage_percent > 80.0 or\n                (caps.gpu_available and state.gpu_usage_percent > 80.0)):\n                if self.power_mode != PowerMode.PERFORMANCE:\n                    self.power_mode = PowerMode.BALANCED\n            else:\n                # If usage is low and we're not in thermal management, consider power save\n                temp_ok = (not caps.temperature_sensors_available or\n                          (state.cpu_temp_celsius < self.constraints.max_cpu_temp_celsius * 0.7 and\n                           state.gpu_temp_celsius < self.constraints.max_gpu_temp_celsius * 0.7))\n\n                if (state.cpu_usage_percent < 30.0 and\n                    (not caps.gpu_available or state.gpu_usage_percent < 30.0) and\n                    temp_ok):\n                    self.power_mode = PowerMode.POWER_SAVE\n                else:\n                    self.power_mode = PowerMode.BALANCED\n\n        except Exception as e:\n            self.logger.error(f"Error adjusting power mode: {e}")\n            # Default to balanced mode if we can't determine appropriate mode\n            self.power_mode = PowerMode.BALANCED\n\n    def get_power_mode(self) -> PowerMode:\n        """Get current power mode"""\n        return self.power_mode\n\n    def set_power_mode(self, mode: PowerMode):\n        """Set power mode manually with validation"""\n        if isinstance(mode, PowerMode):\n            self.power_mode = mode\n            self.logger.info(f"Power mode set to {mode.value}")\n        else:\n            self.logger.error(f"Invalid power mode: {mode}")\n\n    def get_task_queue_status(self) -> Dict[str, Any]:\n        """Get status of task queue with error handling"""\n        try:\n            return {\n                'pending_tasks': len(self.tasks),\n                'running_tasks': len(self.running_tasks),\n                'power_mode': self.power_mode.value,\n                'current_state': {\n                    'cpu_usage': self.power_state.cpu_usage_percent,\n                    'gpu_usage': self.power_state.gpu_usage_percent,\n                    'cpu_temp': self.power_state.cpu_temp_celsius,\n                    'gpu_temp': self.power_state.gpu_temp_celsius\n                }\n            }\n        except Exception as e:\n            self.logger.error(f"Error getting task queue status: {e}")\n            return {\n                'pending_tasks': 0,\n                'running_tasks': 0,\n                'power_mode': self.power_mode.value,\n                'current_state': {\n                    'cpu_usage': 0.0,\n                    'gpu_usage': 0.0,\n                    'cpu_temp': 0.0,\n                    'gpu_temp': 0.0\n                }\n            }\n\n    def register_callback(self, callback: Callable[[str, Any], None]):\n        """Register a callback for power-related events"""\n        if callable(callback):\n            self.callbacks.append(callback)\n        else:\n            self.logger.error("Callback must be callable")\n\n    def _execute_tasks(self):\n        """Internal method to execute pending tasks"""\n        try:\n            self.execute_tasks()\n        except Exception as e:\n            self.logger.error(f"Error in task execution: {e}")\n\n\nclass RobustThermalManager:\n    """\n    Thermal management system with hardware detection and fallback mechanisms.\n    Prevents overheating while maintaining system stability under varying loads.\n    """\n\n    def __init__(self, constraints: PowerConstraint, hardware_interface: SafeHardwareInterface):\n        self.constraints = constraints\n        self.hardware_interface = hardware_interface\n        self.is_active = False\n        self.monitoring_thread = None\n        self.callbacks: List[Callable] = []\n        self.performance_throttle_factor = 1.0  # 1.0 = no throttle, 0.0 = max throttle\n\n        # Initialize logging\n        self.logger = logging.getLogger(__name__)\n\n        # Initialize thermal zones and cooling devices based on hardware detection\n        self._initialize_thermal_system()\n\n    def _initialize_thermal_system(self):\n        """Initialize thermal management system based on detected hardware"""\n        caps = self.hardware_interface.hardware_detector.capabilities\n\n        self.logger.info(f"Initializing thermal management for detected hardware:")\n        self.logger.info(f"  - CPU available: {caps.cpu_available}")\n        self.logger.info(f"  - GPU available: {caps.gpu_available}")\n        self.logger.info(f"  - Temperature sensors: {caps.temperature_sensors_available}")\n\n    def register_callback(self, callback: Callable[[str, float], None]):\n        """Register a callback to be called when thermal events occur"""\n        if callable(callback):\n            self.callbacks.append(callback)\n        else:\n            self.logger.error("Callback must be callable")\n\n    def _notify_callbacks(self, event_type: str, value: float):\n        """Notify all registered callbacks of a thermal event"""\n        for callback in self.callbacks:\n            try:\n                callback(event_type, value)\n            except Exception as e:\n                self.logger.error(f"Error in thermal callback: {str(e)}")\n\n    def adjust_cooling(self, zone_name: str, temperature: float):\n        """Adjust cooling based on temperature in a specific zone with fallbacks"""\n        try:\n            # Find the thermal zone\n            if zone_name.lower() == 'cpu':\n                max_temp = self.constraints.max_cpu_temp_celsius\n            elif zone_name.lower() == 'gpu':\n                max_temp = self.constraints.max_gpu_temp_celsius\n            else:\n                self.logger.warning(f"Unknown thermal zone: {zone_name}")\n                return\n\n            # Calculate how much above the safe threshold we are\n            safe_temp = max_temp * 0.8\n            critical_temp = max_temp\n\n            if temperature >= critical_temp:\n                # Critical temperature - performance reduction\n                self.performance_throttle_factor = 0.3  # Reduce performance by 70%\n                self._notify_callbacks("critical_temp", temperature)\n                self.logger.critical(f"CRITICAL TEMPERATURE in {zone_name}: {temperature}°C")\n            elif temperature >= safe_temp:\n                # Above safe threshold - moderate performance reduction\n                excess = (temperature - safe_temp) / (critical_temp - safe_temp)\n                self.performance_throttle_factor = max(0.5, 1.0 - excess * 0.5)  # Scale from 1.0 to 0.5\n                self._notify_callbacks("high_temp", temperature)\n                self.logger.warning(f"HIGH TEMPERATURE in {zone_name}: {temperature}°C")\n            else:\n                # Temperature is safe - restore normal performance\n                self.performance_throttle_factor = 1.0\n                self._notify_callbacks("safe_temp", temperature)\n\n        except Exception as e:\n            self.logger.error(f"Error adjusting cooling for {zone_name}: {e}")\n\n    def start_management(self, monitoring_interval: float = 1.0):\n        """Start thermal management with error handling"""\n        if self.is_active:\n            return\n\n        self.is_active = True\n        try:\n            self.monitoring_thread = threading.Thread(\n                target=self._monitoring_loop,\n                args=(monitoring_interval,)\n            )\n            self.monitoring_thread.daemon = True\n            self.monitoring_thread.start()\n            self.logger.info("Started thermal management")\n        except Exception as e:\n            self.logger.error(f"Failed to start thermal management: {e}")\n            self.is_active = False\n\n    def stop_management(self):\n        """Stop thermal management"""\n        self.is_active = False\n        if self.monitoring_thread:\n            try:\n                self.monitoring_thread.join(timeout=2.0)\n            except Exception as e:\n                self.logger.error(f"Error stopping thermal management thread: {e}")\n        self.logger.info("Stopped thermal management")\n\n    def _monitoring_loop(self, interval: float):\n        """Main thermal monitoring loop with error handling"""\n        while self.is_active:\n            try:\n                # Get current thermal state\n                self._check_and_manage_thermal_state()\n\n                # Sleep for the specified interval\n                time.sleep(interval)\n            except Exception as e:\n                self.logger.error(f"Error in thermal monitoring loop: {str(e)}")\n                # Continue monitoring even if there's an error\n                time.sleep(interval)\n\n    def _check_and_manage_thermal_state(self):\n        """Check thermal state and adjust cooling as needed"""\n        try:\n            # Get CPU temperature\n            cpu_temp = self.hardware_interface.get_temperature('cpu')\n            self.adjust_cooling('CPU', cpu_temp)\n\n            # Get GPU temperature if GPU is available\n            if self.hardware_interface.hardware_detector.capabilities.gpu_available:\n                gpu_temp = self.hardware_interface.get_temperature('gpu')\n                self.adjust_cooling('GPU', gpu_temp)\n\n        except Exception as e:\n            self.logger.error(f"Error checking thermal state: {e}")\n\n    def get_thermal_summary(self) -> Dict[str, Any]:\n        """Get a summary of thermal state and management"""\n        try:\n            caps = self.hardware_interface.hardware_detector.capabilities\n\n            summary = {\n                "cpu_temp_celsius": self.hardware_interface.get_temperature('cpu'),\n                "gpu_temp_celsius": self.hardware_interface.get_temperature('gpu') if caps.gpu_available else 0.0,\n                "max_cpu_temp_celsius": self.constraints.max_cpu_temp_celsius,\n                "max_gpu_temp_celsius": self.constraints.max_gpu_temp_celsius if caps.gpu_available else 0.0,\n                "performance_throttle_factor": self.performance_throttle_factor,\n                "active": self.is_active,\n                "temperature_sensors_available": caps.temperature_sensors_available\n            }\n\n            return summary\n        except Exception as e:\n            self.logger.error(f"Error getting thermal summary: {e}")\n            return {\n                "cpu_temp_celsius": 0.0,\n                "gpu_temp_celsius": 0.0,\n                "max_cpu_temp_celsius": self.constraints.max_cpu_temp_celsius,\n                "max_gpu_temp_celsius": self.constraints.max_gpu_temp_celsius,\n                "performance_throttle_factor": 1.0,\n                "active": self.is_active,\n                "temperature_sensors_available": False\n            }\n\n    def get_performance_throttle_factor(self) -> float:\n        """Get the current performance throttle factor (1.0 = no throttle, 0.0 = max throttle)"""\n        return self.performance_throttle_factor\n\n\ndef create_robust_power_management_system(\n    hardware_interface: SafeHardwareInterface,\n    constraints: Optional[PowerConstraint] = None\n) -> Tuple[RobustPowerAwareScheduler, RobustThermalManager]:\n    """\n    Create a robust power management system with hardware-appropriate configurations.\n\n    Args:\n        hardware_interface: Safe hardware interface with detection and fallbacks\n        constraints: Optional power constraints (will be auto-detected if not provided)\n\n    Returns:\n        Tuple of (PowerAwareScheduler, ThermalManager)\n    """\n    # Auto-detect constraints based on hardware if not provided\n    if constraints is None:\n        caps = hardware_interface.hardware_detector.capabilities\n        constraints = PowerConstraint()\n\n        # Adjust constraints based on detected hardware\n        if not caps.gpu_available:\n            constraints.max_gpu_power_watts = 0.0\n            constraints.max_gpu_temp_celsius = 0.0\n\n        if not caps.temperature_sensors_available:\n            # Use conservative values when temperature sensors are not available\n            constraints.max_cpu_temp_celsius = 85.0\n            constraints.max_gpu_temp_celsius = 80.0\n\n    # Create the power management components\n    scheduler = RobustPowerAwareScheduler(constraints, hardware_interface)\n    thermal_manager = RobustThermalManager(constraints, hardware_interface)\n\n    # Register thermal callbacks to adjust power scheduling based on thermal state\n    def thermal_callback(event_type: str, temperature: float):\n        if event_type == "critical_temp":\n            scheduler.set_power_mode(PowerMode.THERMAL_MANAGEMENT)\n        elif event_type == "high_temp":\n            if scheduler.get_power_mode() != PowerMode.THERMAL_MANAGEMENT:\n                scheduler.set_power_mode(PowerMode.POWER_SAVE)\n        elif event_type == "safe_temp":\n            if scheduler.get_power_mode() == PowerMode.THERMAL_MANAGEMENT:\n                scheduler.set_power_mode(PowerMode.BALANCED)\n\n    thermal_manager.register_callback(thermal_callback)\n\n    return scheduler, thermal_manager\n\n\nif __name__ == "__main__":\n    # Example usage\n    import logging\n    logging.basicConfig(level=logging.INFO)\n\n    print("Initializing Robust Power Management System...")\n\n    # Create hardware interface with detection and fallbacks\n    hardware_interface = SafeHardwareInterface()\n\n    # Create the power management system\n    scheduler, thermal_manager = create_robust_power_management_system(hardware_interface)\n\n    # Add an example task\n    def example_task():\n        print("Executing example task...")\n        time.sleep(2)  # Simulate work\n        return "Task completed"\n\n    scheduler.add_task(example_task, priority=8)  # High priority task\n\n    # Start monitoring\n    scheduler.start_monitoring(interval=1.0)\n    thermal_manager.start_management(interval=1.0)\n\n    # Let it run for a bit\n    time.sleep(10)\n\n    # Check status\n    status = scheduler.get_task_queue_status()\n    print(f"Task queue status: {status}")\n\n    thermal_summary = thermal_manager.get_thermal_summary()\n    print(f"Thermal summary: {thermal_summary}")\n\n    # Stop monitoring\n    scheduler.stop_monitoring()\n    thermal_manager.stop_management()\n\n    print("Robust Power Management System completed successfully!")