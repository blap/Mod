"""\nPlugin system for easily adding new models without major code changes.\n\nThis module provides a plugin system that allows for easy addition of new models.\n"""\n\nimport abc\nimport importlib\nimport os\nfrom typing import Dict, List, Optional, Any, Type, Protocol\nfrom pathlib import Path\nimport logging\nimport sys\n\n\nclass IModelPlugin(Protocol):\n    """Interface for model plugins."""\n    \n    @property\n    def model_name(self) -> str:\n        """Name of the model this plugin supports."""\n        ...\n    \n    @property\n    def model_class(self) -> Type:\n        """Model class this plugin supports."""\n        ...\n    \n    @property\n    def config_class(self) -> Type:\n        """Configuration class this plugin supports."""\n        ...\n    \n    @property\n    def adapter_class(self) -> Optional[Type]:\n        """Adapter class this plugin supports (optional)."""\n        ...\n    \n    def get_model_spec(self) -> Dict[str, Any]:\n        """Get model specification for registration."""\n        ...\n    \n    def initialize(self) -> bool:\n        """Initialize the plugin."""\n        ...\n    \n    def cleanup(self) -> bool:\n        """Clean up the plugin."""\n        ...\n\n\nclass BaseModelPlugin(IModelPlugin, abc.ABC):\n    """Base class for model plugins."""\n    \n    def __init__(self):\n        self._initialized = False\n        self._logger = logging.getLogger(f"{self.__class__.__module__}.{self.__class__.__name__}")\n    \n    @property\n    @abc.abstractmethod\n    def model_name(self) -> str:\n        """Name of the model this plugin supports."""\n        pass\n    \n    @property\n    @abc.abstractmethod\n    def model_class(self) -> Type:\n        """Model class this plugin supports."""\n        pass\n    \n    @property\n    @abc.abstractmethod\n    def config_class(self) -> Type:\n        """Configuration class this plugin supports."""\n        pass\n    \n    @property\n    def adapter_class(self) -> Optional[Type]:\n        """Adapter class this plugin supports (optional)."""\n        return None\n    \n    def get_model_spec(self) -> Dict[str, Any]:\n        """Get model specification for registration."""\nfrom models.model_registry import ModelSpec\n        \n        return {\n            "name": self.model_name,\n            "model_class": self.model_class,\n            "config_class": self.config_class,\n            "adapter_class": self.adapter_class,\n            "supported_dtypes": ["float16", "float32", "bfloat16"],\n            "required_memory_gb": 8.0,\n            "max_sequence_length": 2048,\n            "description": f"Model plugin for {self.model_name}",\n            "model_type": "language"  # Can be overridden by subclasses\n        }\n    \n    def initialize(self) -> bool:\n        """Initialize the plugin."""\n        try:\n            self._initialized = True\n            self._logger.info(f"Plugin initialized for {self.model_name}")\n            return True\n        except Exception as e:\n            self._logger.error(f"Error initializing plugin for {self.model_name}: {e}")\n            return False\n    \n    def cleanup(self) -> bool:\n        """Clean up the plugin."""\n        try:\n            self._initialized = False\n            self._logger.info(f"Plugin cleaned up for {self.model_name}")\n            return True\n        except Exception as e:\n            self._logger.error(f"Error cleaning up plugin for {self.model_name}: {e}")\n            return False\n\n\nclass ModelPluginManager:\n    """\n    Manager for handling model plugins.\n    """\n    \n    def __init__(self):\n        self._logger = logging.getLogger(f"{self.__class__.__module__}.{self.__class__.__name__}")\n        self._plugins: Dict[str, IModelPlugin] = {}\n        self._loaded_plugin_paths: List[str] = []\n    \n    def register_plugin(self, plugin: IModelPlugin) -> bool:\n        """\n        Register a model plugin.\n        \n        Args:\n            plugin: IModelPlugin instance to register\n            \n        Returns:\n            True if registration was successful, False otherwise\n        """\n        try:\n            if not plugin.initialize():\n                self._logger.error(f"Failed to initialize plugin: {plugin.model_name}")\n                return False\n            \n            self._plugins[plugin.model_name] = plugin\n            self._logger.info(f"Plugin registered for {plugin.model_name}")\n            return True\n        except Exception as e:\n            self._logger.error(f"Error registering plugin: {e}")\n            return False\n    \n    def unregister_plugin(self, model_name: str) -> bool:\n        """\n        Unregister a model plugin.\n        \n        Args:\n            model_name: Name of the model whose plugin to unregister\n            \n        Returns:\n            True if unregistration was successful, False otherwise\n        """\n        if model_name not in self._plugins:\n            self._logger.warning(f"No plugin found for {model_name}")\n            return False\n        \n        try:\n            plugin = self._plugins[model_name]\n            plugin.cleanup()\n            del self._plugins[model_name]\n            self._logger.info(f"Plugin unregistered for {model_name}")\n            return True\n        except Exception as e:\n            self._logger.error(f"Error unregistering plugin for {model_name}: {e}")\n            return False\n    \n    def get_plugin(self, model_name: str) -> Optional[IModelPlugin]:\n        """\n        Get a registered plugin.\n        \n        Args:\n            model_name: Name of the model\n            \n        Returns:\n            Plugin if found, None otherwise\n        """\n        return self._plugins.get(model_name)\n    \n    def get_all_plugins(self) -> List[IModelPlugin]:\n        """\n        Get all registered plugins.\n        \n        Returns:\n            List of all registered plugins\n        """\n        return list(self._plugins.values())\n    \n    def load_plugin_from_module(self, module_path: str) -> bool:\n        """\n        Load a plugin from a Python module file.\n        \n        Args:\n            module_path: Path to the Python module containing the plugin\n            \n        Returns:\n            True if loading was successful, False otherwise\n        """\n        try:\n            # Add the directory containing the module to sys.path if not already there\n            module_dir = os.path.dirname(module_path)\n            if module_dir not in sys.path:\n                sys.path.insert(0, module_dir)\n            \n            # Import the module\n            module_name = Path(module_path).stem\n            spec = importlib.util.spec_from_file_location(module_name, module_path)\n            if spec is None or spec.loader is None:\n                self._logger.error(f"Could not load spec from {module_path}")\n                return False\n            \n            module = importlib.util.module_from_spec(spec)\n            spec.loader.exec_module(module)\n            \n            # Find plugin classes in the module\n            plugin_classes = []\n            for attr_name in dir(module):\n                attr = getattr(module, attr_name)\n                if (isinstance(attr, type) and \n                    attr != BaseModelPlugin and \n                    issubclass(attr, BaseModelPlugin)):\n                    plugin_classes.append(attr)\n            \n            if not plugin_classes:\n                self._logger.error(f"No plugin classes found in {module_path}")\n                return False\n            \n            # Create and register instances of plugin classes\n            for plugin_class in plugin_classes:\n                plugin_instance = plugin_class()\n                if not self.register_plugin(plugin_instance):\n                    self._logger.error(f"Failed to register plugin: {plugin_class.__name__}")\n                    return False\n            \n            self._loaded_plugin_paths.append(module_path)\n            return True\n            \n        except Exception as e:\n            self._logger.error(f"Error loading plugin from {module_path}: {e}")\n            return False\n    \n    def load_plugins_from_directory(self, directory_path: str) -> bool:\n        """\n        Load all plugins from a directory.\n        \n        Args:\n            directory_path: Path to the directory containing plugin files\n            \n        Returns:\n            True if loading was successful, False otherwise\n        """\n        try:\n            directory = Path(directory_path)\n            if not directory.exists() or not directory.is_dir():\n                self._logger.error(f"Directory {directory_path} does not exist or is not a directory")\n                return False\n            \n            # Find all Python files in the directory\n            python_files = list(directory.glob("*.py"))\n            \n            success = True\n            for py_file in python_files:\n                if py_file.name.startswith('__'):\n                    continue  # Skip __init__.py and similar files\n                \n                if not self.load_plugin_from_module(str(py_file)):\n                    self._logger.error(f"Failed to load plugin from {py_file}")\n                    success = False\n            \n            return success\n            \n        except Exception as e:\n            self._logger.error(f"Error loading plugins from directory {directory_path}: {e}")\n            return False\n    \n    def apply_plugins_to_registry(self) -> bool:\n        """\n        Apply all loaded plugins to the model registry.\n        \n        Returns:\n            True if successful, False otherwise\n        """\n        try:\nfrom models.model_registry import get_model_registry, ModelSpec\n            \n            registry = get_model_registry()\n            \n            for plugin in self._plugins.values():\n                spec_data = plugin.get_model_spec()\n                model_spec = ModelSpec(**spec_data)\n                \n                if not registry.register_model(model_spec):\n                    self._logger.error(f"Failed to register model from plugin: {plugin.model_name}")\n                    return False\n            \n            self._logger.info(f"Applied {len(self._plugins)} plugins to model registry")\n            return True\n            \n        except Exception as e:\n            self._logger.error(f"Error applying plugins to registry: {e}")\n            return False\n\n\n# Global plugin manager instance\nplugin_manager = ModelPluginManager()\n\n\ndef get_plugin_manager() -> ModelPluginManager:\n    """\n    Get the global plugin manager instance.\n    \n    Returns:\n        ModelPluginManager instance\n    """\n    return plugin_manager\n\n\n# Example plugin for Qwen3-4B-Instruct-2507 model\nclass Qwen3_4B_Instruct_Plugin(BaseModelPlugin):\n    """Plugin for Qwen3-4B-Instruct-2507 model."""\n    \n    @property\n    def model_name(self) -> str:\n        return "Qwen3-4B-Instruct-2507"\n    \n    @property\n    def model_class(self) -> Type:\n        # Import the model class - in practice, this would be the actual Qwen3-4B class\nfrom models.base_model import Qwen3VLModel\n        return Qwen3VLModel  # Placeholder - should be the actual model class\n    \n    @property\n    def config_class(self) -> Type:\n        # Import the config class - in practice, this would be the actual Qwen3-4B config\nfrom qwen3_vl.config.base_config import Qwen3VLConfig\n        return Qwen3VLConfig  # Placeholder - should be the actual config class\n    \n    @property\n    def adapter_class(self) -> Optional[Type]:\nfrom models.model_registry import Qwen3VLAdapter\n        return Qwen3VLAdapter  # Placeholder - should be the actual adapter class\n    \n    def get_model_spec(self) -> Dict[str, Any]:\n        spec = super().get_model_spec()\n        spec.update({\n            "supported_dtypes": ["float16", "float32", "bfloat16"],\n            "required_memory_gb": 6.0,\n            "max_sequence_length": 32768,\n            "description": "Qwen3 4B Instruct model (2507 version)",\n            "model_type": "language"\n        })\n        return spec\n\n\n# Register the example plugin\ndef _register_default_plugins():\n    """Register default plugins."""\n    qwen3_4b_plugin = Qwen3_4B_Instruct_Plugin()\n    plugin_manager.register_plugin(qwen3_4b_plugin)\n\n\n_register_default_plugins()