"""\nModel registry system for managing multiple supported models in Qwen3-VL project.\n\nThis module provides:\n1. A model registry system that can manage multiple supported models\n2. Model-specific configuration loading that adapts to different architectures\n3. Adaptive memory management that adjusts based on model size and requirements\n4. Model loading and initialization that handles different formats and sizes\n5. Hardware optimization profiles that adapt to different model characteristics\n6. A plugin system for easily adding new models without major code changes\n7. Model-specific optimization strategies (quantization, sparsity, etc.)\n8. Performance optimization that can scale based on model size\n9. Configuration validation for different model types\n10. A model adapter layer that provides a unified interface across different models\n"""\n\nimport abc\nimport logging\nfrom typing import Dict, List, Optional, Type, Any, Protocol, Union\nfrom dataclasses import dataclass, field\nfrom pathlib import Path\nimport threading\nimport torch\nimport torch.nn as nn\n\n\nclass IModelAdapter(Protocol):\n    """Interface for model adapters that provide a unified interface across different models."""\n    \n    def forward(self, *args, **kwargs):\n        """Forward pass of the model."""\n        ...\n    \n    def generate(self, *args, **kwargs):\n        """Generate text using the model."""\n        ...\n    \n    def load_model(self, model_path: str, config: Optional[Dict[str, Any]] = None) -> 'IModelAdapter':\n        """Load the model from a path."""\n        ...\n    \n    def get_config(self) -> Dict[str, Any]:\n        """Get the model configuration."""\n        ...\n\n\n@dataclass\nclass ModelSpec:\n    """Specification for a registered model."""\n    name: str\n    model_class: Type[nn.Module]\n    config_class: Type[Any]\n    adapter_class: Optional[Type[IModelAdapter]] = None\n    supported_dtypes: List[str] = field(default_factory=lambda: ["float16", "float32", "bfloat16"])\n    required_memory_gb: float = 8.0\n    max_sequence_length: int = 2048\n    description: str = ""\n    model_type: str = "language"  # "language", "vision", "multimodal", "other"\n\n\nclass ModelRegistry:\n    """\n    Centralized registry for managing different model types in the Qwen3-VL project.\n    """\n    \n    _instance = None\n    _lock = threading.RLock()\n    \n    def __new__(cls):\n        """Ensure singleton pattern."""\n        if cls._instance is None:\n            with cls._lock:\n                if cls._instance is None:\n                    cls._instance = super().__new__(cls)\n        return cls._instance\n    \n    def __init__(self):\n        """Initialize the model registry."""\n        # Only initialize once\n        if hasattr(self, '_initialized'):\n            return\n            \n        self._models: Dict[str, ModelSpec] = {}\n        self._logger = logging.getLogger(f"{self.__class__.__module__}.{self.__class__.__name__}")\n        self._registry_lock = threading.RLock()\n        self._initialized = True\n    \n    def register_model(self, model_spec: ModelSpec) -> bool:\n        """\n        Register a model in the registry.\n        \n        Args:\n            model_spec: ModelSpec instance containing model information\n            \n        Returns:\n            True if registration was successful, False otherwise\n        """\n        with self._registry_lock:\n            try:\n                if model_spec.name in self._models:\n                    self._logger.warning(f"Model {model_spec.name} already registered, replacing")\n                \n                self._models[model_spec.name] = model_spec\n                self._logger.info(f"Model {model_spec.name} registered successfully")\n                return True\n            except Exception as e:\n                self._logger.error(f"Error registering model {model_spec.name}: {e}")\n                return False\n    \n    def unregister_model(self, model_name: str) -> bool:\n        """\n        Unregister a model from the registry.\n        \n        Args:\n            model_name: Name of the model to unregister\n            \n        Returns:\n            True if unregistration was successful, False otherwise\n        """\n        with self._registry_lock:\n            if model_name not in self._models:\n                self._logger.warning(f"Model {model_name} not found in registry")\n                return False\n            \n            try:\n                del self._models[model_name]\n                self._logger.info(f"Model {model_name} unregistered successfully")\n                return True\n            except Exception as e:\n                self._logger.error(f"Error unregistering model {model_name}: {e}")\n                return False\n    \n    def get_model_spec(self, model_name: str) -> Optional[ModelSpec]:\n        """\n        Get the specification for a model.\n        \n        Args:\n            model_name: Name of the model\n            \n        Returns:\n            ModelSpec if found, None otherwise\n        """\n        with self._registry_lock:\n            return self._models.get(model_name)\n    \n    def get_all_model_specs(self) -> List[ModelSpec]:\n        """\n        Get all registered model specifications.\n        \n        Returns:\n            List of all ModelSpec instances\n        """\n        with self._registry_lock:\n            return list(self._models.values())\n    \n    def get_model_names(self) -> List[str]:\n        """\n        Get all registered model names.\n        \n        Returns:\n            List of all model names\n        """\n        with self._registry_lock:\n            return list(self._models.keys())\n    \n    def is_model_registered(self, model_name: str) -> bool:\n        """\n        Check if a model is registered.\n        \n        Args:\n            model_name: Name of the model to check\n            \n        Returns:\n            True if model is registered, False otherwise\n        """\n        with self._registry_lock:\n            return model_name in self._models\n    \n    def get_model_by_type(self, model_type: str) -> List[ModelSpec]:\n        """\n        Get all models of a specific type.\n        \n        Args:\n            model_type: Type of models to retrieve ("language", "vision", "multimodal", "other")\n            \n        Returns:\n            List of ModelSpec instances of the specified type\n        """\n        with self._registry_lock:\n            return [spec for spec in self._models.values() if spec.model_type == model_type]\n\n\n# Global registry instance\nmodel_registry = ModelRegistry()\n\n\ndef get_model_registry() -> ModelRegistry:\n    """\n    Get the global model registry instance.\n    \n    Returns:\n        ModelRegistry instance\n    """\n    return model_registry\n\n\nclass BaseModelAdapter(IModelAdapter, abc.ABC):\n    """\n    Abstract base class for model adapters that provide a unified interface.\n    """\n    \n    def __init__(self, model: nn.Module, config: Optional[Dict[str, Any]] = None):\n        self.model = model\n        self.config = config or {}\n    \n    @abc.abstractmethod\n    def forward(self, *args, **kwargs):\n        """Forward pass implementation."""\n        pass\n    \n    @abc.abstractmethod\n    def generate(self, *args, **kwargs):\n        """Generation implementation."""\n        pass\n    \n    @abc.abstractmethod\n    def load_model(self, model_path: str, config: Optional[Dict[str, Any]] = None) -> 'BaseModelAdapter':\n        """Load model implementation."""\n        pass\n    \n    @abc.abstractmethod\n    def get_config(self) -> Dict[str, Any]:\n        """Get configuration implementation."""\n        pass\n\n\nclass Qwen3VLAdapter(BaseModelAdapter):\n    """\n    Adapter for Qwen3-VL models providing a unified interface.\n    """\n    \n    def forward(self, *args, **kwargs):\n        """Forward pass for Qwen3-VL model."""\n        return self.model(*args, **kwargs)\n    \n    def generate(self, *args, **kwargs):\n        """Generate text using Qwen3-VL model."""\n        return self.model.generate(*args, **kwargs)\n    \n    def load_model(self, model_path: str, config: Optional[Dict[str, Any]] = None) -> 'Qwen3VLAdapter':\n        """Load Qwen3-VL model from path."""\nfrom models.base_model import create_model_from_pretrained\n        model = create_model_from_pretrained(model_path, config)\n        return Qwen3VLAdapter(model, config)\n    \n    def get_config(self) -> Dict[str, Any]:\n        """Get Qwen3-VL model configuration."""\n        if hasattr(self.model, 'config'):\n            return self.model.config.__dict__\n        return self.config\n\n\nclass ModelFactory:\n    """\n    Factory class for creating model instances based on registered specifications.\n    """\n    \n    def __init__(self, registry: ModelRegistry = None):\n        self.registry = registry or get_model_registry()\n    \n    def create_model(\n        self,\n        model_name: str,\n        config: Optional[Dict[str, Any]] = None,\n        pretrained_model_name_or_path: Optional[str] = None,\n        **kwargs\n    ) -> Union[nn.Module, IModelAdapter]:\n        """\n        Create a model instance based on the registered specification.\n        \n        Args:\n            model_name: Name of the model to create\n            config: Configuration to use for the model\n            pretrained_model_name_or_path: Path to pretrained model (optional)\n            **kwargs: Additional arguments\n            \n        Returns:\n            Model instance or adapter\n        """\n        model_spec = self.registry.get_model_spec(model_name)\n        if not model_spec:\n            raise ValueError(f"Model {model_name} is not registered in the model registry")\n        \n        # Create configuration\n        if config is None:\n            config = {}\n        \n        # Create model instance\n        if pretrained_model_name_or_path:\n            # Load from pretrained\n            model = model_spec.model_class.from_pretrained(\n                pretrained_model_name_or_path,\n                **config\n            )\n        else:\n            # Create from config\n            model_config = model_spec.config_class(**config)\n            model = model_spec.model_class(model_config)\n        \n        # If an adapter is specified, wrap the model\n        if model_spec.adapter_class:\n            return model_spec.adapter_class(model, config)\n        \n        return model\n    \n    def list_available_models(self) -> List[str]:\n        """List all available models in the registry."""\n        return self.registry.get_model_names()\n    \n    def get_model_info(self, model_name: str) -> Optional[ModelSpec]:\n        """Get information about a specific model."""\n        return self.registry.get_model_spec(model_name)\n\n\n# Register the default Qwen3-VL model\ndef _register_default_models():\n    """Register default models in the registry."""\nfrom models.base_model import Qwen3VLModel\nfrom qwen3_vl.config.base_config import Qwen3VLConfig\n    \n    qwen3_vl_spec = ModelSpec(\n        name="Qwen3-VL",\n        model_class=Qwen3VLModel,\n        config_class=Qwen3VLConfig,\n        adapter_class=Qwen3VLAdapter,\n        supported_dtypes=["float16", "float32", "bfloat16"],\n        required_memory_gb=8.0,\n        max_sequence_length=32768,\n        description="Default Qwen3-VL multimodal model",\n        model_type="multimodal"\n    )\n    \n    model_registry.register_model(qwen3_vl_spec)\n\n\n# Register default models when module is imported\n_register_default_models()